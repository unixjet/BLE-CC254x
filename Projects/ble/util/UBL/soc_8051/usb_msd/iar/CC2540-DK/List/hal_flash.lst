###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.30.1.41636 for 8051             27/Jan/2014  15:09:31 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\hal\hal_flash.c       #
#    Command line       =  E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\hal\hal_flash.c -D    #
#                          HAL_SB_BOOT_CODE -D UBL_BUILD -lC                  #
#                          E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\iar\CC2540-DK\List\   #
#                          -lA E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projec #
#                          ts\ble\util\UBL\soc_8051\usb_msd\iar\CC2540-DK\Lis #
#                          t\ --remarks -o E:\mgzhou\Study\CC2540\BLE-CC254x- #
#                          1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\iar\C #
#                          C2540-DK\Obj\ -e --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Project #
#                          s\ble\util\UBL\soc_8051\usb_msd\iar\..\app\ -I     #
#                          E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\iar\..\hal\ -I        #
#                          E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\iar\..\hal\usb\ -I    #
#                          E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\iar\..\hal\usb\class_ #
#                          msd\ -I E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Pr #
#                          ojects\ble\util\UBL\soc_8051\usb_msd\iar\..\hal\us #
#                          b\library\ -Ohz --require_prototypes --mfc         #
#                          E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\app\ubl_exec.c        #
#                          E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\app\ubl_main.c        #
#                          E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_d #
#                          escriptor_parser.c E:\mgzhou\Study\CC2540\BLE-CC25 #
#                          4x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\ha #
#                          l\usb\library\usb_framework.c                      #
#                          E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\hal\usb\usb_interrupt #
#                          .c E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Project #
#                          s\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\us #
#                          b_standard_requests.c E:\mgzhou\Study\CC2540\BLE-C #
#                          C254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd #
#                          \hal\usb\usb_suspend.c                             #
#    List file          =  E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\iar\CC2540-DK\List\ha #
#                          l_flash.lst                                        #
#    Object file        =  E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\b #
#                          le\util\UBL\soc_8051\usb_msd\iar\CC2540-DK\Obj\hal #
#                          _flash.r51                                         #
#                                                                             #
#                                                                             #
###############################################################################

E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\hal_flash.c
      1          /**************************************************************************************************
      2            Filename:       hal_flash.c
      3            Revised:        $Date: 2012-08-31 11:31:40 -0700 (Fri, 31 Aug 2012) $
      4            Revision:       $Revision: 31449 $
      5          
      6            Description: This file contains the interface to the H/W Flash driver.
      7          
      8          
      9            Copyright 2006-2011 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          #include "hal_board_cfg.h"

   \                                 In  segment SFR_AN, at 0x8b
   \   unsigned char volatile __sfr P2IFG
   \                     P2IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x96
   \   unsigned char volatile __sfr ST1
   \                     ST1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x97
   \   unsigned char volatile __sfr ST2
   \                     ST2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc7
   \   unsigned char volatile __sfr MEMCTR
   \                     MEMCTR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc9
   \   unsigned char volatile __sfr WDCTL
   \                     WDCTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd4
   \   unsigned char volatile __sfr DMA0CFGL
   \                     DMA0CFGL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd5
   \   unsigned char volatile __sfr DMA0CFGH
   \                     DMA0CFGH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1
     46          #include "hal_dma.h"
     47          #include "hal_flash.h"
     48          #include "hal_mcu.h"
     49          #include "hal_types.h"
     50          
     51          /**************************************************************************************************
     52           * @fn          HalFlashRead
     53           *
     54           * @brief       This function reads 'cnt' bytes from the internal flash.
     55           *
     56           * input parameters
     57           *
     58           * @param       pg - A valid flash page number.
     59           * @param       offset - A valid offset into the page.
     60           * @param       buf - A valid buffer space at least as big as the 'cnt' parameter.
     61           * @param       cnt - A valid number of bytes to read.
     62           *
     63           * output parameters
     64           *
     65           * None.
     66           *
     67           * @return      None.
     68           **************************************************************************************************
     69           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     70          void HalFlashRead(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt)
   \                     HalFlashRead:
     71          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
     72            // Calculate the offset into the containing flash bank as it gets mapped into XDATA.
     73            uint8 *pData = (uint8 *)(offset + HAL_FLASH_PAGE_MAP) +
     74                           ((pg % HAL_FLASH_PAGE_PER_BANK) * HAL_FLASH_PAGE_SIZE);
   \   000007   740F         MOV     A,#0xf
   \   000009   55..         ANL     A,?V0
   \   00000B   F5..         MOV     ?V2,A
   \   00000D   75..00       MOV     ?V3,#0x0
   \   000010   740B         MOV     A,#0xb
   \   000012   78..         MOV     R0,#?V2
   \   000014   12....       LCALL   ?S_SHL
   \   000017   EA           MOV     A,R2
   \   000018   2400         ADD     A,#0x0
   \   00001A   F8           MOV     R0,A
   \   00001B   EB           MOV     A,R3
   \   00001C   3480         ADDC    A,#-0x80
   \   00001E   F9           MOV     R1,A
   \   00001F   E8           MOV     A,R0
   \   000020   2400         ADD     A,#0x0
   \   000022   E9           MOV     A,R1
   \   000023   35..         ADDC    A,?V3
   \   000025   F9           MOV     R1,A
     75            uint8 memctr = MEMCTR;  // Save to restore.
   \   000026   E5C7         MOV     A,0xc7
   \   000028   F5..         MOV     ?V1,A
     76          
     77          #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
     78            halIntState_t is;
     79          #endif
     80          
     81            pg /= HAL_FLASH_PAGE_PER_BANK;  // Calculate the flash bank from the flash page.
     82          
     83          #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
     84            HAL_ENTER_CRITICAL_SECTION(is);
   \   00002A   A2AF         MOV     C,0xa8.7
   \   00002C   E4           CLR     A
   \   00002D   33           RLC     A
   \   00002E   F5..         MOV     ?V2,A
   \   000030   C2AF         CLR     0xa8.7
     85          #endif
     86          
     87            // Calculate and map the containing flash bank into XDATA.
     88            MEMCTR = (MEMCTR & 0xF8) | pg;
   \   000032   E5..         MOV     A,?V0
   \   000034   C4           SWAP    A
   \   000035   540F         ANL     A,#0xf
   \   000037   FA           MOV     R2,A
   \   000038   E5C7         MOV     A,0xc7
   \   00003A   54F8         ANL     A,#0xf8
   \   00003C   4A           ORL     A,R2
   \   00003D   F5C7         MOV     0xc7,A
   \   00003F   740C         MOV     A,#0xc
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000047   801C         SJMP    ??HalFlashRead_0
     89          
     90            while (cnt--)
     91            {
     92              *buf++ = *pData++;
   \                     ??HalFlashRead_1:
   \   000049   8882         MOV     DPL,R0
   \   00004B   8983         MOV     DPH,R1
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   8C82         MOV     DPL,R4
   \   000050   8D83         MOV     DPH,R5
   \   000052   F0           MOVX    @DPTR,A
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   A3           INC     DPTR
   \   000058   A882         MOV     R0,DPL
   \   00005A   A983         MOV     R1,DPH
   \   00005C   8C82         MOV     DPL,R4
   \   00005E   8D83         MOV     DPH,R5
   \   000060   A3           INC     DPTR
   \   000061   AC82         MOV     R4,DPL
   \   000063   AD83         MOV     R5,DPH
     93            }
   \                     ??HalFlashRead_0:
   \   000065   EA           MOV     A,R2
   \   000066   FE           MOV     R6,A
   \   000067   EB           MOV     A,R3
   \   000068   FF           MOV     R7,A
   \   000069   EE           MOV     A,R6
   \   00006A   24FF         ADD     A,#-0x1
   \   00006C   1A           DEC     R2
   \   00006D   EF           MOV     A,R7
   \   00006E   34FF         ADDC    A,#-0x1
   \   000070   FB           MOV     R3,A
   \   000071   EE           MOV     A,R6
   \   000072   4F           ORL     A,R7
   \   000073   70D4         JNZ     ??HalFlashRead_1
     94          
     95            MEMCTR = memctr;
   \   000075   85..C7       MOV     0xc7,?V1
     96          
     97          #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
     98            HAL_EXIT_CRITICAL_SECTION(is);
   \   000078   E5..         MOV     A,?V2
   \   00007A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00007C   92AF         MOV     0xa8.7,C
     99          #endif
    100          }
   \   00007E   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000081                REQUIRE MEMCTR
   \   000081                REQUIRE _A_IEN0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    101          
    102          /**************************************************************************************************
    103           * @fn          HalFlashWrite
    104           *
    105           * @brief       This function writes 'cnt' bytes to the internal flash.
    106           *
    107           * input parameters
    108           *
    109           * @param       addr - Valid HAL flash write address: actual addr / 4 and quad-aligned.
    110           * @param       buf - Valid buffer space at least as big as 'cnt' X 4.
    111           * @param       cnt - Number of 4-byte blocks to write.
    112           *
    113           * output parameters
    114           *
    115           * None.
    116           *
    117           * @return      None.
    118           **************************************************************************************************
    119           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    120          void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
   \                     HalFlashWrite:
    121          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    122            halDMADesc_t *ch = HAL_NV_DMA_GET_DESC();
    123          
    124            HAL_DMA_SET_SOURCE(ch, buf);
   \   000005   ED           MOV     A,R5
   \   000006   90....       MOV     DPTR,#dmaCh0
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   EC           MOV     A,R4
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
    125            HAL_DMA_SET_DEST(ch, &FWDATA);
   \   00000D   A3           INC     DPTR
   \   00000E   7462         MOV     A,#0x62
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   7473         MOV     A,#0x73
   \   000014   F0           MOVX    @DPTR,A
    126            HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_USE_LEN);
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   541F         ANL     A,#0x1f
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   740A         MOV     A,#0xa
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ?Subroutine13 & 0xFFFF
    127            HAL_DMA_SET_LEN(ch, (cnt * HAL_FLASH_WORD_SIZE));
   \                     ??CrossCallReturnLabel_11:
   \   000022   33           RLC     A
   \   000023   33           RLC     A
   \   000024   54FC         ANL     A,#0xfc
   \   000026   90....       MOV     DPTR,#dmaCh0 + 5
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   7406         MOV     A,#0x6
   \   00002C   78..         MOV     R0,#?V0
   \   00002E   12....       LCALL   ?US_SHR
   \   000031   E5..         MOV     A,?V0
   \   000033   90....       MOV     DPTR,#dmaCh0 + 4
   \   000036   F0           MOVX    @DPTR,A
    128            HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
    129            HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
    130            HAL_DMA_SET_TRIG_SRC(ch, HAL_DMA_TRIG_FLASH);
   \   000037   90....       MOV     DPTR,#dmaCh0 + 6
   \   00003A   7412         MOV     A,#0x12
   \   00003C   F0           MOVX    @DPTR,A
    131            HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
    132            HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
    133            // The DMA is to be polled and shall not issue an IRQ upon completion.
    134            HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_DISABLE);
    135            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS);
    136            HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
   \   00003D   A3           INC     DPTR
   \   00003E   7442         MOV     A,#0x42
   \   000040   F0           MOVX    @DPTR,A
    137            HAL_DMA_CLEAR_IRQ(HAL_NV_DMA_CH);
   \   000041   75D1FE       MOV     0xd1,#-0x2
    138            HAL_DMA_ARM_CH(HAL_NV_DMA_CH);
   \   000044   75D601       MOV     0xd6,#0x1
    139          
    140            FADDRL = (uint8)addr;
   \   000047   EA           MOV     A,R2
   \   000048   906271       MOV     DPTR,#0x6271
   \   00004B   F0           MOVX    @DPTR,A
    141            FADDRH = (uint8)(addr >> 8);
   \   00004C   EB           MOV     A,R3
   \   00004D   A3           INC     DPTR
   \   00004E   F0           MOVX    @DPTR,A
    142            FCTL |= 0x02;         // Trigger the DMA writes.
   \   00004F   906270       MOV     DPTR,#0x6270
   \   000052   E0           MOVX    A,@DPTR
   \   000053   D2E1         SETB    0xE0 /* A   */.1
   \   000055   F0           MOVX    @DPTR,A
    143            while (FCTL & 0x80);  // Wait until writing is done.
   \                     ??HalFlashWrite_0:
   \   000056   E0           MOVX    A,@DPTR
   \   000057   A2E7         MOV     C,0xE0 /* A   */.7
   \   000059   40FB         JC      ??HalFlashWrite_0
    144          }
   \   00005B   02....       LJMP    ??Subroutine27_0 & 0xFFFF
   \   00005E                REQUIRE DMAIRQ
   \   00005E                REQUIRE DMAARM

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V1,A
   \   000007   E5..         MOV     A,?V0
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine27_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    145          
    146          /**************************************************************************************************
    147           * @fn          HalFlashErase
    148           *
    149           * @brief       This function erases the specified page of the internal flash.
    150           *
    151           * input parameters
    152           *
    153           * @param       pg - A valid flash page number to erase.
    154           *
    155           * output parameters
    156           *
    157           * None.
    158           *
    159           * @return      None.
    160           **************************************************************************************************
    161           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    162          void HalFlashErase(uint8 pg)
   \                     HalFlashErase:
    163          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    164            FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
   \   000004   E9           MOV     A,R1
   \   000005   C3           CLR     C
   \   000006   33           RLC     A
   \   000007   906272       MOV     DPTR,#0x6272
   \   00000A   02....       LJMP    ?Subroutine2 & 0xFFFF
    165            FCTL |= 0x01;
    166          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   906270       MOV     DPTR,#0x6270
   \   000004   E0           MOVX    A,@DPTR
   \   000005   D2E0         SETB    0xE0 /* A   */.0
   \   000007                REQUIRE ??Subroutine29_0
   \   000007                ; // Fall through to label ??Subroutine29_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                REQUIRE ??Subroutine30_0
   \   000001                ; // Fall through to label ??Subroutine30_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    167          
    168          /**************************************************************************************************
    169          */
E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_exec.c
      1          /**************************************************************************************************
      2            Filename:       ubl_exec.c
      3            Revised:        $Date: 2012-09-07 14:26:14 -0700 (Fri, 07 Sep 2012) $
      4            Revision:       $Revision: 31498 $
      5          
      6            Description:
      7          
      8            This module implements the executive functionality of a Universal Boot Loader
      9            for an 8051-based SOC using the USB transport by MSD.
     10          
     11          
     12            Copyright 2011-2012 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights
     15            granted under the terms of a software license agreement between the user
     16            who downloaded the software, his/her employer (which must be your employer)
     17            and Texas Instruments Incorporated (the "License").  You may not use this
     18            Software unless you agree to abide by the terms of the License. The License
     19            limits your use, and you acknowledge, that the Software may not be modified,
     20            copied or distributed unless embedded on a Texas Instruments microcontroller
     21            or used solely and exclusively in conjunction with a Texas Instruments radio
     22            frequency transceiver, which is integrated into your product.  Other than for
     23            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     24            works of, modify, distribute, perform, display or sell this Software and/or
     25            its documentation for any purpose.
     26          
     27            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     28            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     29            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     30            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     31            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     32            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     33            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     34            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     35            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     36            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     37            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     38          
     39            Should you have any questions regarding your right to use this Software,
     40            contact Texas Instruments Incorporated at www.TI.com.
     41          **************************************************************************************************/
     42          
     43          /* ------------------------------------------------------------------------------------------------
     44           *                                          Includes
     45           * ------------------------------------------------------------------------------------------------
     46           */
     47          
     48          #include <stddef.h>
     49          #include <string.h>
     50          
     51          #include "hal_board_cfg.h"
     52          #include "hal_dma.h"
     53          #include "hal_flash.h"
     54          #include "hal_types.h"
     55          #include "ubl_app.h"
     56          #include "ubl_exec.h"
     57          #include "usb_msd.h"
     58          
     59          /* ------------------------------------------------------------------------------------------------
     60           *                                          Constants
     61           * ------------------------------------------------------------------------------------------------
     62           */
     63          
     64          #if !defined HAL_DONGLE_NANO
     65          #define UBL_GPIO_USE
     66          #endif
     67          
     68          // Define the checksum-subset of the Meta Data for checksum calculation and copying so as not to
     69          // overwrite ong.
     70          #define UBL_MD_CHKLEN  (offsetof(ublMetaData_t, cntDnForced) - offsetof(ublMetaData_t, chkMD))
     71          

   \                                 In  segment XDATA_ROM_C, align 1
     72          static const uint8 unlockedSecKey[32] =
   \                     ??unlockedSecKey:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255
   \   000008   FF           DB 255
   \   000009   FF           DB 255
   \   00000A   FF           DB 255
   \   00000B   FF           DB 255
   \   00000C   FF           DB 255
   \   00000D   FF           DB 255
   \   00000E   FF           DB 255
   \   00000F   FF           DB 255
   \   000010   FF           DB 255
   \   000011   FF           DB 255
   \   000012   FF           DB 255
   \   000013   FF           DB 255
   \   000014   FF           DB 255
   \   000015   FF           DB 255
   \   000016   FF           DB 255
   \   000017   FF           DB 255
   \   000018   FF           DB 255
   \   000019   FF           DB 255
   \   00001A   FF           DB 255
   \   00001B   FF           DB 255
   \   00001C   FF           DB 255
   \   00001D   FF           DB 255
   \   00001E   FF           DB 255
   \   00001F   FF           DB 255
     73          {
     74            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     75            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
     76          };
     77          
     78          /***                 The following are "Write" addresses for HalFlashWrite().                  ***/
     79          #define UBL_META_DATA_ADDR_WR  \
     80            ((uint16)(UBL_META_DATA_PAGE * ((uint16)(HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE))) + \
     81                                            (uint16)(UBL_META_DATA_IDX / HAL_FLASH_WORD_SIZE))
     82          
     83          #define UBL_CNTDN_FORCED_ADDR (UBL_META_DATA_ADDR_WR + \
     84                                        (offsetof(ublMetaData_t, cntDnForced) / HAL_FLASH_WORD_SIZE))
     85          #define UBL_CNTDN_SECKEY_ADDR (UBL_META_DATA_ADDR_WR + \
     86                                        (offsetof(ublMetaData_t, cntDnSecKey) / HAL_FLASH_WORD_SIZE))
     87          /***                  The above are "Write" addresses for HalFlashWrite().                    ***/
     88          
     89          // Allow test & development with final structures and memeory map without the burden of having to
     90          // encrypt and sign every image to download until ready with the production build.
     91          #if !defined UBL_SECURE
     92          #define UBL_SECURE                   FALSE
     93          #endif
     94          
     95          #if UBL_SECURE
     96          static const uint8 aesKey[KEY_BLENGTH] = {
     97            // This dummy key must be replaced by a randomly generated key that is kept secret.
     98            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
     99          };
    100          #endif
    101          
    102          // Set UBL_SIGNER=TRUE in order to create a special boot loader that will accept
    103          // an un-encrypted/un-authenticated image via download and then sign it and send it back
    104          // with encryption on the read back.
    105          #if !defined UBL_SIGNER
    106          #define UBL_SIGNER                   FALSE
    107          #endif
    108          
    109          #if UBL_SIGNER
    110          #if !UBL_SECURE
    111          #error Mismatched definitions for UBL_SIGNER and UBL_SECURE.
    112          #else
    113          #warning You built a special "Signing" boot loader - do not release to market ... internal use only.
    114          #endif
    115          #endif
    116          
    117          /* ------------------------------------------------------------------------------------------------
    118           *                                           Macros
    119           * ------------------------------------------------------------------------------------------------
    120           */
    121          
    122          #define UBL_READ_ST(STCNT) st (             \
    123            do {  /* Get the sleep timer count; ST0 must be read first & re-read to verify. */\
    124              ((uint8 *) &(STCNT))[0] = ST0;          \
    125            } while (((uint8 *) &(STCNT))[0] != ST0); \
    126            ((uint8 *) &(STCNT))[1] = ST1;            \
    127            ((uint8 *) &(STCNT))[2] = ST2;            \
    128            ((uint8 *) &(STCNT))[3] = 0;              \
    129          )
    130          
    131          /* ------------------------------------------------------------------------------------------------
    132           *                                       Global Variables
    133           * ------------------------------------------------------------------------------------------------
    134           */
    135          

   \                                 In  segment XDATA_ROM_C, align 1
    136          const uint8 UBL_RC_IMG_PG_BEG = UBL_PAGE_FIRST;
   \                     UBL_RC_IMG_PG_BEG:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ROM_C, align 1
    137          const uint8 UBL_RC_IMG_PG_END = UBL_PAGE_LAST;
   \                     UBL_RC_IMG_PG_END:
   \   000000   77           DB 119
    138          
    139          /* ------------------------------------------------------------------------------------------------
    140           *                                       Global Variables
    141           * ------------------------------------------------------------------------------------------------
    142           */
    143          

   \                                 In  segment XDATA_N, align 1
    144          __no_init uint8 pgBuf[HAL_FLASH_PAGE_SIZE];  // RAM (XDATA) buffer for an Rx/Tx flash page.
   \                     pgBuf:
   \   000000                DS 2048

   \                                 In  segment XDATA_N, align 1
    145          __no_init ublMetaData_t ublMD;
   \                     ublMD:
   \   000000                DS 100
    146          
    147          /* ------------------------------------------------------------------------------------------------
    148           *                                       Local Variables
    149           * ------------------------------------------------------------------------------------------------
    150           */
    151          
    152          #if defined UBL_GPIO_USE

   \                                 In  segment XDATA_N, align 1
    153          static __no_init volatile uint8 *pForcePort;
   \                     ??pForcePort:
   \   000000                DS 2

   \                                 In  segment XDATA_N, align 1
    154          static __no_init uint8 forcePin;
   \                     ??forcePin:
   \   000000                DS 1
    155          #endif

   \                                 In  segment XDATA_N, align 1
    156          static __no_init uint32 stStart, stDelay;
   \                     ??stStart:
   \   000000                DS 4

   \                                 In  segment XDATA_N, align 1
   \                     ??stDelay:
   \   000000                DS 4
    157          
    158          #if UBL_SECURE
    159          // Flag when built with UBL_SIGNER=TRUE to encrypt the read back.
    160          static bool signMode;
    161          #endif
    162          
    163          /* ------------------------------------------------------------------------------------------------
    164           *                                       Local Functions
    165           * ------------------------------------------------------------------------------------------------
    166           */
    167          
    168          #if UBL_SECURE
    169          static uint8 aesCheckCtrl(void *pBuf);
    170          static void  aesLoadKey(void);
    171          static void  aesInitSig(void);
    172          #endif
    173          
    174          static bool cntDnForcedDecr(void);
    175          #if defined UBL_GPIO_USE
    176          static bool gpioInit(void);
    177          #endif
    178          static void vddWait(void);
    179          
    180          /**************************************************************************************************
    181           * @fn          ublAesAuth
    182           *
    183           * @brief       Run the AES CRC-MAC authentication calculation over the RC image according to the
    184           *              AES Control Block parameters and update the control block accordingly.
    185           *              Just set CRC shadow equal to CRC when no valid security key built into the UBL.
    186           *
    187           * input parameters
    188           *
    189           * None.
    190           *
    191           * output parameters
    192           *
    193           * None.
    194           *
    195           * @return      TRUE or FALSE whether the AES signature of the image in flash is valid.
    196           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    197          uint8 ublAesAuth(void)
   \                     ublAesAuth:
    198          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    199          #if UBL_SECURE
    200            uint8 pgCnt = 0;
    201            uint8 sigBuf[KEY_BLENGTH];
    202          
    203            aes_ctrl_blk_t ctrlBlk;
    204            UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
    205          
    206            aesInitSig();
    207          
    208            for (uint8 pgNum = UBL_PAGE_FIRST; pgNum <= UBL_PAGE_LAST; pgNum++)
    209            {
    210              if (!GET_BIT(ublMD.writeEn, pgNum))
    211              {
    212                continue;
    213              }
    214          
    215              pgCnt++;
    216          
    217              HalFlashRead(pgNum, 0, pgBuf, HAL_FLASH_PAGE_SIZE);
    218          
    219              for (uint16 oset = 0; oset < HAL_FLASH_PAGE_SIZE; )
    220              {
    221                if ((pgCnt == 1) && (oset == 0))
    222                {
    223                  oset += KEY_BLENGTH;  // Must not include the signature bytes in the signature calculation.
    224                }
    225                else if ((pgCnt == ctrlBlk.imageLen) && (oset == (HAL_FLASH_PAGE_SIZE - KEY_BLENGTH)))
    226                {
    227                  break;  // Need to change mode to CBC-MAC for the last block.
    228                }
    229          
    230                ENCCS |= 0x01;
    231                for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
    232                {
    233                  ENCDI = pgBuf[oset++];
    234                }
    235                while ((ENCCS & BV(3)) == 0);
    236              }
    237          
    238              if (pgCnt >= ctrlBlk.imageLen)
    239              {
    240                break;
    241              }
    242            }
    243          
    244            ENCCS = CBC | AES_ENCRYPT | 0x01;  // Switch to CBC mode for the last block.
    245          
    246            // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    247            // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    248            ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    249          
    250            for (uint16 oset = (HAL_FLASH_PAGE_SIZE - KEY_BLENGTH); oset < HAL_FLASH_PAGE_SIZE; oset++)
    251            {
    252              ENCDI = pgBuf[oset];
    253            }
    254            HAL_AES_DELAY();  // Delay required for non-DMA AES as RDY bit only goes hi after read out below.
    255          
    256            // CBC-MAC generates output on the last block.
    257            for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
    258            {
    259              sigBuf[cnt] = ENCDO;
    260            }
    261          
    262            if (ctrlBlk.allowSignCmd != 0)  // If requested to sign this image.
    263            {
    264              ctrlBlk.allowSignCmd = 0;
    265              (void)memcpy(ctrlBlk.signature, sigBuf, KEY_BLENGTH);
    266              UBL_NVM_SET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
    267              UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
    268            }
    269          
    270          #if UBL_SIGNER
    271            signMode = TRUE;  // Now the Signer should encrypt the read back.
    272          #else  // A signer must always return FALSE so that usb_msd.c does not save the file name to flash.
    273            if (memcmp(ctrlBlk.signature, sigBuf, KEY_BLENGTH))
    274          #endif
    275            {
    276              return FALSE;
    277            }
    278          #endif
    279          
    280            HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD.crcRC, 4);
   \   000005                ; Setup parameters for call to function HalFlashRead
   \   000005   75..04       MOV     ?V0,#0x4
   \   000008   75..00       MOV     ?V1,#0x0
   \   00000B   78..         MOV     R0,#?V0
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   7C..         MOV     R4,#ublMD & 0xff
   \   000012   7D..         MOV     R5,#(ublMD >> 8) & 0xff
   \   000014   7A9C         MOV     R2,#-0x64
   \   000016   7B06         MOV     R3,#0x6
   \   000018   7901         MOV     R1,#0x1
   \   00001A   12....       LCALL   ??HalFlashRead?relay ; Banked call to: HalFlashRead
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?DEALLOC_XSTACK8
    281          
    282            ublMD.crcShdw = ublMD.crcRC;
   \   000022   90....       MOV     DPTR,#ublMD
   \   000025   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000028   A3           INC     DPTR
   \   000029   E8           MOV     A,R0
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   E9           MOV     A,R1
   \   00002D   F0           MOVX    @DPTR,A
    283            ublMD.crcRC = UBL_CRC_ERASED;  // Do not write zero to the same bits more than twice.
   \   00002E   90....       MOV     DPTR,#ublMD
   \   000031   74FF         MOV     A,#-0x1
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   F0           MOVX    @DPTR,A
    284            HalFlashWrite(UBL_META_DATA_ADDR_WR, (uint8 *)&ublMD.crcRC, 1);
   \   000036                ; Setup parameters for call to function HalFlashWrite
   \   000036   75..01       MOV     ?V0,#0x1
   \   000039   78..         MOV     R0,#?V0
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   7C..         MOV     R4,#ublMD & 0xff
   \   000040   7D..         MOV     R5,#(ublMD >> 8) & 0xff
   \   000042   7AA7         MOV     R2,#-0x59
   \   000044   7B03         MOV     R3,#0x3
   \   000046   12....       LCALL   ??HalFlashWrite?relay; Banked call to: HalFlashWrite
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
    285          
    286            return TRUE;
   \   00004E   7901         MOV     R1,#0x1
   \   000050   02....       LJMP    ??Subroutine27_0 & 0xFFFF
    287          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    288          
    289          /**************************************************************************************************
    290           * @fn          ublAesCrypt
    291           *
    292           * @brief       UBL AES encryption/decyption for the low-level transport driver.
    293           *              Just return when no valid security key built into the UBL.
    294           *
    295           * input parameters
    296           *
    297           * @param       pgNum - HAL Flash page number corresponding to the pgBuf.
    298           * @param       pgBuf - Pointer to the page buffer to crypt in place.
    299           *
    300           * output parameters
    301           *
    302           * @param       pgBuf - Pointer to the page buffer of crypted bytes.
    303           *
    304           * @return      TRUE or FALSE whether the AES image page is valid (i.e. the ctrl block on 1st page).
    305           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    306          uint8 ublAesCrypt(uint8 pgNum, uint8 *pgBuf)
   \                     ublAesCrypt:
    307          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    308          #if UBL_SECURE
    309            if (!UBL_SIGNER || signMode)
    310            {
    311              // A0: L-encoding of L-1 = 2-1 = 1; starting 2-byte CTR at 1.
    312              uint8 ivNonce[KEY_BLENGTH] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
    313              uint8 *pBuf = pgBuf;
    314          
    315              ENCCS = CTR | AES_LOAD_IV | 0x01;
    316          
    317              // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    318              // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    319              ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    320          
    321              for (uint8 idx = 0; idx < KEY_BLENGTH; idx++)
    322              {
    323                ENCDI = ivNonce[idx];
    324              }
    325              while ((ENCCS & BV(3)) == 0);
    326          
    327              for (uint8 cnt = 0; cnt < (HAL_FLASH_PAGE_SIZE / KEY_BLENGTH); cnt++)
    328              {
    329                ENCCS = CTR | AES_ENCRYPT | 0x01;
    330          
    331                // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    332                // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    333                ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    334          
    335                for (uint8 blk = 0; blk < 4; blk++)
    336                {
    337                  for (uint8 idx = 0; idx < 4; idx++)
    338                  {
    339                    ENCDI = pBuf[idx];
    340                  }
    341          
    342                  HAL_AES_DELAY();  // Delay required for non-DMA AES as RDY bit only goes hi after read out.
    343          
    344                  for (uint8 idx = 0; idx < 4; idx++)
    345                  {
    346                    pBuf[idx] = ENCDO;
    347                  }
    348          
    349                  pBuf += 4;
    350                }
    351              }
    352          
    353              if ((pgNum == UBL_PAGE_FIRST) && !aesCheckCtrl(pgBuf))
    354              {
    355                return FALSE;
    356              }
    357            }
    358          #else
    359            (void)pgNum;
    360            (void)pgBuf;
    361          #endif
    362          
    363            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
    364          }
    365          
    366          /**************************************************************************************************
    367           * @fn          ublCfg
    368           *
    369           * @brief       Configure according to the received meta-data file if it checks out.
    370           *
    371           * input parameters
    372           *
    373           * @param       pMD - Pointer to the received meta-data file.
    374           *
    375           * output parameters
    376           *
    377           * None.
    378           *
    379           * @return      TRUE if the cfg file is acceptable; FALSE otherwise.
    380           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    381          bool ublCfg(ublMetaData_t *pMD)
   \                     ublCfg:
    382          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    383            // Thwart an attempt to break-in by an exhaustive Security Key trial-and-error.
    384            if (!UBL_UNLOCKED && (memcmp(&ublMD.secKey, &pMD->secKey, sizeof(ublMD.secKey)) != 0))
   \   00000E   90....       MOV     DPTR,#ublMD + 99
   \   000011   E0           MOVX    A,@DPTR
   \   000012   606D         JZ      ??ublCfg_0
   \   000014                ; Setup parameters for call to function memcmp
   \   000014   75..20       MOV     ?V0,#0x20
   \   000017   75..00       MOV     ?V1,#0x0
   \   00001A   78..         MOV     R0,#?V0
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001F   EE           MOV     A,R6
   \   000020   2408         ADD     A,#0x8
   \   000022   FC           MOV     R4,A
   \   000023   E4           CLR     A
   \   000024   3F           ADDC    A,R7
   \   000025   FD           MOV     R5,A
   \   000026   7A..         MOV     R2,#(ublMD + 8) & 0xff
   \   000028   7B..         MOV     R3,#((ublMD + 8) >> 8) & 0xff
   \   00002A   12....       LCALL   ??memcmp?relay       ; Banked call to: memcmp
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000032   8B..         MOV     ?V1,R3
   \   000034   EA           MOV     A,R2
   \   000035   45..         ORL     A,?V1
   \   000037   6048         JZ      ??ublCfg_0
    385            {
    386              if (ublMD.cntDnSecKey == 0)
   \   000039   90....       MOV     DPTR,#ublMD + 96
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   7901         MOV     R1,#0x1
   \   000040   7011         JNZ     ??ublCfg_1
    387              {
    388                ublMassErase(TRUE);  // Force the erase of all pages outside of the UBL image.
   \   000042                ; Setup parameters for call to function ublMassErase
   \   000042   12....       LCALL   ??ublMassErase?relay ; Banked call to: ublMassErase
    389                HAL_SYSTEM_RESET();
   \   000045   C2AF         CLR     0xa8.7
   \   000047   75C9AB       MOV     0xc9,#-0x55
   \   00004A   75C95B       MOV     0xc9,#0x5b
   \                     ??ublCfg_2:
   \   00004D   80FE         SJMP    ??ublCfg_2
    390              }
    391              else
    392              {
    393                uint8 mask = 0x01;
    394          
    395                while ((mask & ublMD.cntDnSecKey) == 0)
    396                {
    397                  mask <<= 1;
   \                     ??ublCfg_3:
   \   00004F   E9           MOV     A,R1
   \   000050   C3           CLR     C
   \   000051   33           RLC     A
   \   000052   F9           MOV     R1,A
    398                }
   \                     ??ublCfg_1:
   \   000053   E9           MOV     A,R1
   \   000054   58           ANL     A,R0
   \   000055   60F8         JZ      ??ublCfg_3
    399                ublMD.cntDnSecKey ^= mask;
   \   000057   E0           MOVX    A,@DPTR
   \   000058   69           XRL     A,R1
   \   000059   F0           MOVX    @DPTR,A
    400          
    401                // This will write zero to exactly one bit, so no bit is written to zero twice.
    402                uint8 secKeyAndPad[4] = { 0xFF, 0xFF, 0xFF, 0xFF };
   \   00005A   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255}>`
   \   00005D   AC..         MOV     R4,?XSP + 0
   \   00005F   AD..         MOV     R5,?XSP + 1
   \   000061   7404         MOV     A,#0x4
   \   000063   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    403                secKeyAndPad[0] ^= mask;
   \   000066   12....       LCALL   ?Subroutine12 & 0xFFFF
    404                HalFlashWrite(UBL_CNTDN_SECKEY_ADDR, secKeyAndPad, 1);
    405              }
    406            }
   \                     ??CrossCallReturnLabel_9:
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   7402         MOV     A,#0x2
   \   00006E   12....       LCALL   ?XSTACK_DISP102_8
   \   000071   7ABF         MOV     R2,#-0x41
   \   000073   7B03         MOV     R3,#0x3
   \   000075   12....       LCALL   ??HalFlashWrite?relay; Banked call to: HalFlashWrite
   \   000078   7402         MOV     A,#0x2
   \   00007A   12....       LCALL   ?DEALLOC_XSTACK8
    407            else
    408            {
    409              UBL_UNLOCK();
    410              (void)memcpy(&ublMD.chkMD, &pMD->chkMD, UBL_MD_CHKLEN);
    411              ublMD.crcShdw = UBL_CRC_ZEROED;  // Receiving a "cfg" file is a de facto force of UBL mode.
    412              return TRUE;
    413            }
    414          
    415            return FALSE;
   \   00007D   7900         MOV     R1,#0x0
   \   00007F   802B         SJMP    ??ublCfg_4
   \                     ??ublCfg_0:
   \   000081   90....       MOV     DPTR,#ublMD + 99
   \   000084   E4           CLR     A
   \   000085   F0           MOVX    @DPTR,A
   \   000086                ; Setup parameters for call to function memcpy
   \   000086   75..58       MOV     ?V0,#0x58
   \   000089   F5..         MOV     ?V1,A
   \   00008B   78..         MOV     R0,#?V0
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000090   EE           MOV     A,R6
   \   000091   2404         ADD     A,#0x4
   \   000093   FC           MOV     R4,A
   \   000094   E4           CLR     A
   \   000095   3F           ADDC    A,R7
   \   000096   FD           MOV     R5,A
   \   000097   7A..         MOV     R2,#(ublMD + 4) & 0xff
   \   000099   7B..         MOV     R3,#((ublMD + 4) >> 8) & 0xff
   \   00009B   12....       LCALL   ??memcpy?relay       ; Banked call to: memcpy
   \   00009E   7402         MOV     A,#0x2
   \   0000A0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A3   90....       MOV     DPTR,#ublMD + 2
   \   0000A6   E4           CLR     A
   \   0000A7   F0           MOVX    @DPTR,A
   \   0000A8   A3           INC     DPTR
   \   0000A9   F0           MOVX    @DPTR,A
   \   0000AA   7901         MOV     R1,#0x1
   \                     ??ublCfg_4:
   \   0000AC   7404         MOV     A,#0x4
   \   0000AE                REQUIRE ?Subroutine5
   \   0000AE                REQUIRE _A_IEN0
   \   0000AE                REQUIRE WDCTL
   \   0000AE                ; // Fall through to label ?Subroutine5
    416          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   02....       LJMP    ??Subroutine27_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   69           XRL     A,R1
   \   000008   F0           MOVX    @DPTR,A
   \   000009                ; Setup parameters for call to function HalFlashWrite
   \   000009                ; Setup parameters for call to function HalFlashWrite
   \   000009   75..01       MOV     ?V0,#0x1
   \   00000C   75..00       MOV     ?V1,#0x0
   \   00000F   78..         MOV     R0,#?V0
   \   000011   22           RET
    417          
    418          /**************************************************************************************************
    419           * @fn          ublExec
    420           *
    421           * @brief       UBL executive loop for polling and managing environment.
    422           *
    423           * input parameters
    424           *
    425           * None.
    426           *
    427           * output parameters
    428           *
    429           * None.
    430           *
    431           * @return      None.
    432           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    433          void ublExec(void)
   \                     ublExec:
    434          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8007         SJMP    ??ublExec_0
    435            while (1)
    436            {
    437              // No continual waits for VDD_MIN_NV - Vdd is assumed to be stable on a USB-powered device.
    438              //vddWait();
    439          
    440              if (usb_msd_poll() == TRUE)  // TRUE == "Eject".
    441              {
    442                break;
    443              }
    444          
    445              if (UBL_RC_VALID && (ublMD.dlyJmp != 0))
    446              {
    447          #if defined UBL_GPIO_USE
    448                if (!GET_BIT(ublMD.cfgDiscs+0, gpioUseNot) &&
    449                    (GET_BIT(ublMD.cfgDiscs+0, gpioPolarity) == ((*pForcePort & BV(forcePin)) != 0)))
    450                {
    451                  ublMD.crcShdw = UBL_CRC_ZEROED;
   \                     ??ublExec_1:
   \   00000C   90....       MOV     DPTR,#ublMD + 2
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
    452                }
   \                     ??ublExec_0:
   \   000013                ; Setup parameters for call to function usb_msd_poll
   \   000013   12....       LCALL   ??usb_msd_poll?relay ; Banked call to: usb_msd_poll
   \   000016   E9           MOV     A,R1
   \   000017   6401         XRL     A,#0x1
   \   000019   90....       MOV     DPTR,#ublMD
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??ublExec_2 & 0xFFFF
   \   000021   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000024   7003         JNZ     ??ublExec_3
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   69           XRL     A,R1
   \                     ??ublExec_3:
   \   000029   70E8         JNZ     ??ublExec_0
   \   00002B   90....       MOV     DPTR,#ublMD
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F4           CPL     A
   \   000030   7003         JNZ     ??ublExec_4
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F4           CPL     A
   \                     ??ublExec_4:
   \   000035   60DC         JZ      ??ublExec_0
   \   000037   E8           MOV     A,R0
   \   000038   49           ORL     A,R1
   \   000039   60D8         JZ      ??ublExec_0
   \   00003B   90....       MOV     DPTR,#ublMD + 6
   \   00003E   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000041   60D0         JZ      ??ublExec_0
   \   000043   90....       MOV     DPTR,#ublMD + 88
   \   000046   E0           MOVX    A,@DPTR
   \   000047   A2E0         MOV     C,0xE0 /* A   */.0
   \   000049   4034         JC      ??ublExec_5
   \   00004B   A2E1         MOV     C,0xE0 /* A   */.1
   \   00004D   5004         JNC     ??ublExec_6
   \   00004F   D2F0         SETB    B.0
   \   000051   8002         SJMP    ??ublExec_7
   \                     ??ublExec_6:
   \   000053   C2F0         CLR     B.0
   \                     ??ublExec_7:
   \   000055   A2F0         MOV     C,B.0
   \   000057   E4           CLR     A
   \   000058   33           RLC     A
   \   000059   FA           MOV     R2,A
   \   00005A   75..01       MOV     ?V0,#0x1
   \   00005D   75..00       MOV     ?V1,#0x0
   \   000060   90....       MOV     DPTR,#??forcePin
   \   000063   E0           MOVX    A,@DPTR
   \   000064   78..         MOV     R0,#?V0
   \   000066   12....       LCALL   ?S_SHL
   \   000069   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00006C   55..         ANL     A,?V0
   \   00006E   6004         JZ      ??ublExec_8
   \   000070   D2F0         SETB    B.0
   \   000072   8002         SJMP    ??ublExec_9
   \                     ??ublExec_8:
   \   000074   C2F0         CLR     B.0
   \                     ??ublExec_9:
   \   000076   EA           MOV     A,R2
   \   000077   A2E0         MOV     C,0xE0 /* A   */.0
   \   000079   20F001       JB      B.0,??ublExec_10
   \   00007C   B3           CPL     C
   \                     ??ublExec_10:
   \   00007D   408D         JC      ??ublExec_1
    453                else
    454          #endif
    455                {
    456                  uint32 stDelta;
    457                  UBL_READ_ST(stDelta);  // Get the free-running count of 30.5 usec timer ticks.
   \                     ??ublExec_5:
   \   00007F   E595         MOV     A,0x95
   \   000081   85..82       MOV     DPL,?XSP + 0
   \   000084   85..83       MOV     DPH,?XSP + 1
   \   000087   F0           MOVX    @DPTR,A
   \   000088   6595         XRL     A,0x95
   \   00008A   70F3         JNZ     ??ublExec_5
   \   00008C   E596         MOV     A,0x96
   \   00008E   C0E0         PUSH    A
   \   000090   7401         MOV     A,#0x1
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   D0E0         POP     A
   \   000097   F0           MOVX    @DPTR,A
   \   000098   E597         MOV     A,0x97
   \   00009A   C0E0         PUSH    A
   \   00009C   7402         MOV     A,#0x2
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   D0E0         POP     A
   \   0000A3   F0           MOVX    @DPTR,A
   \   0000A4   7403         MOV     A,#0x3
   \   0000A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A9   E4           CLR     A
   \   0000AA   F0           MOVX    @DPTR,A
    458                  stDelta -= stStart;  // Calculate the elapsed ticks of the free-running timer.
   \   0000AB   90....       MOV     DPTR,#??stStart
   \   0000AE   78..         MOV     R0,#?V0
   \   0000B0   12....       LCALL   ?L_MOV_X
   \   0000B3   85..82       MOV     DPL,?XSP + 0
   \   0000B6   85..83       MOV     DPH,?XSP + 1
   \   0000B9   78..         MOV     R0,#?V0
   \   0000BB   12....       LCALL   ?L_SUB_FROM_X
    459                  ((uint8 *)&stDelta)[3] = 0;  // Adjust for a carry on the 24-bit ST counter.
   \   0000BE   7403         MOV     A,#0x3
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   E4           CLR     A
   \   0000C4   F0           MOVX    @DPTR,A
    460          
    461                  if (stDelta > stDelay)
   \   0000C5   85..82       MOV     DPL,?XSP + 0
   \   0000C8   85..83       MOV     DPH,?XSP + 1
   \   0000CB   78..         MOV     R0,#?V0
   \   0000CD   12....       LCALL   ?L_MOV_X
   \   0000D0   90....       MOV     DPTR,#??stDelay
   \   0000D3   78..         MOV     R0,#?V0
   \   0000D5   12....       LCALL   ?UL_GT_X
   \   0000D8   4003         JC      $+5
   \   0000DA   02....       LJMP    ??ublExec_0 & 0xFFFF
   \   0000DD   801A         SJMP    ??ublExec_11
    462                  {
    463                    break;
    464                  }
    465                }
    466              }
    467            }
    468          
    469            if (UBL_RC_VALID)
   \                     ??ublExec_2:
   \   0000DF   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000E2   7003         JNZ     ??ublExec_12
   \   0000E4   A3           INC     DPTR
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   69           XRL     A,R1
   \                     ??ublExec_12:
   \   0000E7   7016         JNZ     ??ublExec_13
   \   0000E9   90....       MOV     DPTR,#ublMD
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   F4           CPL     A
   \   0000EE   7003         JNZ     ??ublExec_14
   \   0000F0   A3           INC     DPTR
   \   0000F1   E0           MOVX    A,@DPTR
   \   0000F2   F4           CPL     A
   \                     ??ublExec_14:
   \   0000F3   600A         JZ      ??ublExec_13
   \   0000F5   E8           MOV     A,R0
   \   0000F6   49           ORL     A,R1
   \   0000F7   6006         JZ      ??ublExec_13
    470            {
    471              usb_msd_uninit();
   \                     ??ublExec_11:
   \   0000F9                ; Setup parameters for call to function usb_msd_uninit
   \   0000F9   12....       LCALL   ??usb_msd_uninit?relay; Banked call to: usb_msd_uninit
    472              ublJump();
   \   0000FC                ; Setup parameters for call to function ublJump
   \   0000FC   12....       LCALL   ??ublJump?relay      ; Banked call to: ublJump
    473            }
    474          }
   \                     ??ublExec_13:
   \   0000FF   7404         MOV     A,#0x4
   \   000101   12....       LCALL   ?DEALLOC_XSTACK8
   \   000104   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000107                REQUIRE ST0
   \   000107                REQUIRE ST1
   \   000107                REQUIRE ST2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   68           XRL     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   90....       MOV     DPTR,#??pForcePort
   \   000003   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine33_0:
   \   000000   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET
    475          
    476          /**************************************************************************************************
    477           * @fn          ublInit
    478           *
    479           * @brief       UBL environment initialization in preparation for running.
    480           *
    481           * input parameters
    482           *
    483           * None.
    484           *
    485           * output parameters
    486           *
    487           * None.
    488           *
    489           * @return      None.
    490           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    491          void ublInit(void)
   \                     ublInit:
    492          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    493            HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD, sizeof(ublMetaData_t));
   \   00000A                ; Setup parameters for call to function HalFlashRead
   \   00000A   75..64       MOV     ?V0,#0x64
   \   00000D   75..00       MOV     ?V1,#0x0
   \   000010   78..         MOV     R0,#?V0
   \   000012   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000015   7C..         MOV     R4,#ublMD & 0xff
   \   000017   7D..         MOV     R5,#(ublMD >> 8) & 0xff
   \   000019   7A9C         MOV     R2,#-0x64
   \   00001B   7B06         MOV     R3,#0x6
   \   00001D   7901         MOV     R1,#0x1
   \   00001F   12....       LCALL   ??HalFlashRead?relay ; Banked call to: HalFlashRead
   \   000022   7402         MOV     A,#0x2
   \   000024   12....       LCALL   ?DEALLOC_XSTACK8
    494          
    495            // If the RC image area is erased or the Application doesn't care about security, unlock the UBL.
    496            if (memcmp(ublMD.secKey, unlockedSecKey, sizeof(unlockedSecKey)) == 0)
   \   000027                ; Setup parameters for call to function memcmp
   \   000027   75..20       MOV     ?V0,#0x20
   \   00002A   78..         MOV     R0,#?V0
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002F   7C..         MOV     R4,#??unlockedSecKey & 0xff
   \   000031   7D..         MOV     R5,#(??unlockedSecKey >> 8) & 0xff
   \   000033   7A..         MOV     R2,#(ublMD + 8) & 0xff
   \   000035   7B..         MOV     R3,#((ublMD + 8) >> 8) & 0xff
   \   000037   12....       LCALL   ??memcmp?relay       ; Banked call to: memcmp
   \   00003A   7402         MOV     A,#0x2
   \   00003C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003F   8B..         MOV     ?V1,R3
   \   000041   EA           MOV     A,R2
   \   000042   45..         ORL     A,?V1
   \   000044   7005         JNZ     ??ublInit_0
    497            {
    498              UBL_UNLOCK();
   \   000046   90....       MOV     DPTR,#ublMD + 99
   \   000049   E4           CLR     A
   \   00004A   F0           MOVX    @DPTR,A
    499            }
    500          
    501            if (UBL_RC_VALID)
   \                     ??ublInit_0:
   \   00004B   90....       MOV     DPTR,#ublMD
   \   00004E   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000051   7003         JNZ     ??ublInit_1
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   69           XRL     A,R1
   \                     ??ublInit_1:
   \   000056   6003         JZ      $+5
   \   000058   02....       LJMP    ??ublInit_2 & 0xFFFF
   \   00005B   90....       MOV     DPTR,#ublMD
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F4           CPL     A
   \   000060   7003         JNZ     ??ublInit_3
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F4           CPL     A
   \                     ??ublInit_3:
   \   000065   7003         JNZ     $+5
   \   000067   02....       LJMP    ??ublInit_2 & 0xFFFF
   \   00006A   E8           MOV     A,R0
   \   00006B   49           ORL     A,R1
   \   00006C   7003         JNZ     $+5
   \   00006E   02....       LJMP    ??ublInit_2 & 0xFFFF
    502            {
    503              if ((ublMD.cntDnForced == 0) || (cntDnForcedDecr() == FALSE))
   \   000071   90....       MOV     DPTR,#ublMD + 92
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F8           MOV     R0,A
   \   000076   603C         JZ      ??ublInit_4
   \   000078   7901         MOV     R1,#0x1
   \   00007A   8004         SJMP    ??ublInit_5
   \                     ??ublInit_6:
   \   00007C   E9           MOV     A,R1
   \   00007D   C3           CLR     C
   \   00007E   33           RLC     A
   \   00007F   F9           MOV     R1,A
   \                     ??ublInit_5:
   \   000080   E9           MOV     A,R1
   \   000081   58           ANL     A,R0
   \   000082   60F8         JZ      ??ublInit_6
   \   000084   E0           MOVX    A,@DPTR
   \   000085   69           XRL     A,R1
   \   000086   F0           MOVX    @DPTR,A
   \   000087   7008         JNZ     ??ublInit_7
   \   000089   90....       MOV     DPTR,#ublMD + 2
   \   00008C   E4           CLR     A
   \   00008D   F0           MOVX    @DPTR,A
   \   00008E   A3           INC     DPTR
   \   00008F   8077         SJMP    ??ublInit_8
   \                     ??ublInit_7:
   \   000091   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255}>_1`
   \   000094   AC..         MOV     R4,?XSP + 0
   \   000096   AD..         MOV     R5,?XSP + 1
   \   000098   7404         MOV     A,#0x4
   \   00009A   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   00009D   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0000A0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A3   7402         MOV     A,#0x2
   \   0000A5   12....       LCALL   ?XSTACK_DISP102_8
   \   0000A8   7ABE         MOV     R2,#-0x42
   \   0000AA   7B03         MOV     R3,#0x3
   \   0000AC   12....       LCALL   ??HalFlashWrite?relay; Banked call to: HalFlashWrite
   \   0000AF   7402         MOV     A,#0x2
   \   0000B1   12....       LCALL   ?DEALLOC_XSTACK8
    504              {
    505          #if defined UBL_GPIO_USE
    506                if (GET_BIT(ublMD.cfgDiscs+0, gpioUseNot) || (gpioInit() == FALSE))
   \                     ??ublInit_4:
   \   0000B4   90....       MOV     DPTR,#ublMD + 88
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000BA   4006         JC      ??ublInit_9
   \   0000BC                ; Setup parameters for call to function gpioInit
   \   0000BC   12....       LCALL   ??gpioInit?relay     ; Banked call to: gpioInit
   \   0000BF   E9           MOV     A,R1
   \   0000C0   7047         JNZ     ??ublInit_2
    507          #endif
    508                {
    509                  if (ublMD.dlyJmp == 0)
   \                     ??ublInit_9:
   \   0000C2   90....       MOV     DPTR,#ublMD + 6
   \   0000C5   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   0000C8   45..         ORL     A,?V1
   \   0000CA   7005         JNZ     ??ublInit_10
    510                  {
    511                    ublJump();
   \   0000CC                ; Setup parameters for call to function ublJump
   \   0000CC   12....       LCALL   ??ublJump?relay      ; Banked call to: ublJump
   \   0000CF   8038         SJMP    ??ublInit_2
    512                  }
    513                  else
    514                  {
    515                    stDelay = (ublMD.dlyJmp * 4096UL) / 125;
   \                     ??ublInit_10:
   \   0000D1   E4           CLR     A
   \   0000D2   F5..         MOV     ?V2,A
   \   0000D4   F5..         MOV     ?V3,A
   \   0000D6   740C         MOV     A,#0xc
   \   0000D8   78..         MOV     R0,#?V0
   \   0000DA   12....       LCALL   ?L_SHL
   \   0000DD   90....       MOV     DPTR,#__Constant_7d
   \   0000E0   78..         MOV     R0,#?V4
   \   0000E2   12....       LCALL   ?L_MOV_X
   \   0000E5   78..         MOV     R0,#?V0
   \   0000E7   79..         MOV     R1,#?V4
   \   0000E9   12....       LCALL   ?UL_DIV_MOD
   \   0000EC   90....       MOV     DPTR,#??stDelay
   \   0000EF   78..         MOV     R0,#?V0
   \   0000F1   12....       LCALL   ?L_MOV_TO_X
    516                    UBL_READ_ST(stStart);
   \                     ??ublInit_11:
   \   0000F4   E595         MOV     A,0x95
   \   0000F6   90....       MOV     DPTR,#??stStart
   \   0000F9   F0           MOVX    @DPTR,A
   \   0000FA   6595         XRL     A,0x95
   \   0000FC   70F6         JNZ     ??ublInit_11
   \   0000FE   E596         MOV     A,0x96
   \   000100   A3           INC     DPTR
   \   000101   F0           MOVX    @DPTR,A
   \   000102   E597         MOV     A,0x97
   \   000104   A3           INC     DPTR
   \   000105   F0           MOVX    @DPTR,A
   \   000106   A3           INC     DPTR
   \   000107   E4           CLR     A
   \                     ??ublInit_8:
   \   000108   F0           MOVX    @DPTR,A
    517                  }
    518                }
    519              }
    520            }
    521          
    522            vddWait();  // Stricter wait then in main, looking for safe Vdd for writing flash.
   \                     ??ublInit_2:
   \   000109   7810         MOV     R0,#0x10
   \                     ??ublInit_12:
   \   00010B   75B60F       MOV     0xb6,#0xf
   \                     ??ublInit_13:
   \   00010E   E5B4         MOV     A,0xb4
   \   000110   A2E7         MOV     C,0xE0 /* A   */.7
   \   000112   50FA         JNC     ??ublInit_13
   \   000114   E5BB         MOV     A,0xbb
   \   000116   C3           CLR     C
   \   000117   944E         SUBB    A,#0x4e
   \   000119   40F0         JC      ??ublInit_12
   \   00011B   18           DEC     R0
   \   00011C   E8           MOV     A,R0
   \   00011D   70EC         JNZ     ??ublInit_12
    523          
    524          #if UBL_SECURE
    525            aesLoadKey();
    526          
    527            aes_ctrl_blk_t ctrlBlk;
    528            UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
    529          
    530            if ((ctrlBlk.allowSignCmd != 0) && (ctrlBlk.imageLen != 0xFF)) // If requested to sign this image.
    531            {
    532              // Signing after checking UBL_RC_VALID ensures run as MSD again so encrypted image can be read.
    533              (void)ublAesAuth();
    534            }
    535          
    536          #if UBL_SIGNER  // A signer must allow image read back of what was written.
    537            for (uint8 idx = 0; idx < 16; idx++)
    538            {
    539              ublMD.readLock[idx] = ublMD.writeEn[idx] ^ 0xFF;
    540            }
    541          #endif
    542          #endif
    543          
    544            usb_msd_init();  // Initialize USB-MSD as late as possible for time limits after enabling D+ line.
   \   00011F                ; Setup parameters for call to function usb_msd_init
   \   00011F   12....       LCALL   ??usb_msd_init?relay ; Banked call to: usb_msd_init
    545          }
   \   000122   7404         MOV     A,#0x4
   \   000124   12....       LCALL   ?DEALLOC_XSTACK8
   \   000127   7F08         MOV     R7,#0x8
   \   000129   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00012C                REQUIRE ST0
   \   00012C                REQUIRE ST1
   \   00012C                REQUIRE ST2
   \   00012C                REQUIRE ADCCON3
   \   00012C                REQUIRE ADCCON1
   \   00012C                REQUIRE ADCH
    546          
    547          /**************************************************************************************************
    548           * @fn          ublJump
    549           *
    550           * @brief       Execute a simple long jump from non-banked UBL code to non-banked RC code space.
    551           *
    552           * input parameters
    553           *
    554           * None.
    555           *
    556           * output parameters
    557           *
    558           * None.
    559           *
    560           * @return      None.
    561           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    562          void ublJump(void)
   \                     ublJump:
    563          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    564            asm("LJMP 0x820\n");  // Immediate jump to run-code.
   \   000000   020820       LJMP 0x820
    565            HAL_SYSTEM_RESET();
   \   000003   C2AF         CLR     0xa8.7
   \   000005   75C9AB       MOV     0xc9,#-0x55
   \   000008   75C95B       MOV     0xc9,#0x5b
   \                     ??ublJump_0:
   \   00000B   80FE         SJMP    ??ublJump_0
   \   00000D                REQUIRE _A_IEN0
   \   00000D                REQUIRE WDCTL
    566          }
    567          
    568          /**************************************************************************************************
    569           * @fn          ublMassErase
    570           *
    571           * @brief       Erase all pages enabled for mass-erase (not including UBL pages or lock bits page).
    572           *
    573           * input parameters
    574           *
    575           * @param       eraseAll - Flag to override the 'eraseEn' bits of the Meta Data.
    576           *
    577           * output parameters
    578           *
    579           * None.
    580           *
    581           * @return      None.
    582           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    583          void ublMassErase(bool eraseAll)
   \                     ublMassErase:
    584          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    585            for (uint8 pg = UBL_RC_IMG_PG_BEG+1; pg <= UBL_PAGE_LAST; pg++)
   \   000004   7802         MOV     R0,#0x2
    586            {
    587              if (eraseAll || GET_BIT(ublMD.eraseEn, pg))
   \                     ??ublMassErase_0:
   \   000006   E9           MOV     A,R1
   \   000007   7027         JNZ     ??ublMassErase_1
   \   000009   E8           MOV     A,R0
   \   00000A   13           RRC     A
   \   00000B   13           RRC     A
   \   00000C   13           RRC     A
   \   00000D   541F         ANL     A,#0x1f
   \   00000F   FA           MOV     R2,A
   \   000010   74..         MOV     A,#(ublMD + 40) & 0xff
   \   000012   2A           ADD     A,R2
   \   000013   F582         MOV     DPL,A
   \   000015   E4           CLR     A
   \   000016   34..         ADDC    A,#((ublMD + 40) >> 8) & 0xff
   \   000018   F583         MOV     DPH,A
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   C0E0         PUSH    A
   \   00001D   7407         MOV     A,#0x7
   \   00001F   58           ANL     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   D0E0         POP     A
   \   000023   BA0002       CJNE    R2,#0x0,??ublMassErase_2
   \   000026   8004         SJMP    ??ublMassErase_3
   \                     ??ublMassErase_2:
   \   000028   C3           CLR     C
   \   000029   13           RRC     A
   \   00002A   DAFC         DJNZ    R2,??ublMassErase_2
   \                     ??ublMassErase_3:
   \   00002C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002E   500E         JNC     ??ublMassErase_4
    588              {
    589                FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
   \                     ??ublMassErase_1:
   \   000030   E8           MOV     A,R0
   \   000031   C3           CLR     C
   \   000032   33           RLC     A
   \   000033   906272       MOV     DPTR,#0x6272
   \   000036   F0           MOVX    @DPTR,A
    590                FCTL |= 0x01;
   \   000037   906270       MOV     DPTR,#0x6270
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   D2E0         SETB    0xE0 /* A   */.0
   \   00003D   F0           MOVX    @DPTR,A
    591              }
    592            }
   \                     ??ublMassErase_4:
   \   00003E   08           INC     R0
   \   00003F   E8           MOV     A,R0
   \   000040   C3           CLR     C
   \   000041   9478         SUBB    A,#0x78
   \   000043   40C1         JC      ??ublMassErase_0
    593          
    594            // Now erase the page with the filename.
    595            FADDRH = UBL_RC_IMG_PG_BEG * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
   \   000045   906272       MOV     DPTR,#0x6272
   \   000048   7402         MOV     A,#0x2
   \   00004A   02....       LJMP    ?Subroutine2 & 0xFFFF
    596            FCTL |= 0x01;
    597          }
    598          
    599          #if UBL_SECURE
    600          /**************************************************************************************************
    601           * @fn          aesCheckCtrl
    602           *
    603           * @brief       Check validity of a AES Control Block before writing it to flash.
    604           *
    605           * input parameters
    606           *
    607           * @param       pBuf - Pointer to the buffer containing the control block.
    608           *
    609           * output parameters
    610           *
    611           * None.
    612           *
    613           * @return      TRUE or FALSE for control block valid.
    614           */
    615          static uint8 aesCheckCtrl(void *pBuf)
    616          {
    617            uint8 sigBuf[KEY_BLENGTH] =
    618             {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    619            aes_ctrl_blk_t *pCtl = (aes_ctrl_blk_t *)pBuf;
    620          
    621          #if UBL_SIGNER
    622            if ( memcmp(pCtl->signature, sigBuf, sizeof(sigBuf))
    623                    || (pCtl->imageLen == 0)
    624                    || (pCtl->imageLen > UBL_PAGE_LAST)
    625                    || (pCtl->allowSignCmd == 0))
    626          #else
    627            if (!memcmp(pCtl->signature, sigBuf, sizeof(sigBuf))
    628                    || (pCtl->imageLen == 0)
    629                    || (pCtl->imageLen > UBL_PAGE_LAST)
    630                    || (pCtl->allowSignCmd != 0))
    631          #endif
    632            {
    633              return FALSE;
    634            }
    635          
    636            return TRUE;
    637          }
    638          
    639          /**************************************************************************************************
    640           * @fn          aesLoadKey
    641           *
    642           * @brief       Load the shared secret key into the AES for operations.
    643           *
    644           * input parameters
    645           *
    646           * None.
    647           *
    648           * output parameters
    649           *
    650           * None.
    651           *
    652           * @return      None.
    653           */
    654          static void aesLoadKey(void)
    655          {
    656            // Read the security key from flash 1 byte at a time to thwart an interrupt & read XDATA attack.
    657            uint8 *keyPtr = (uint8 *)aesKey;
    658          
    659            ENCCS = ECB | AES_LOAD_KEY | 0x01;
    660          
    661            // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    662            // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    663            ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    664          
    665            for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
    666            {
    667              ENCDI = *keyPtr++;
    668            }
    669          }
    670          
    671          /**************************************************************************************************
    672           * @fn          aesInitSig
    673           *
    674           * @brief       Initialize the AES for signature calculation.
    675           *
    676           * input parameters
    677           *
    678           * None.
    679           *
    680           * output parameters
    681           *
    682           * None.
    683           *
    684           * @return      None.
    685           */
    686          static void aesInitSig(void)
    687          {
    688            aes_ctrl_blk_t ctrlBlk;
    689            UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
    690          
    691            ENCCS = CBC_MAC | AES_LOAD_IV | 0x01;
    692          
    693            // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    694            // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    695            ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    696          
    697            for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
    698            {
    699              ENCDI = 0;
    700            }
    701          
    702            ENCCS = CBC_MAC | AES_ENCRYPT | 0x01;
    703          
    704            // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
    705            // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
    706            ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
    707          
    708            ENCDI = 0x3A;  // B0 Flag: Res=0, A_Data=0, (M-2)/2=7, (L-1)=2.
    709          
    710            ENCDI = LO_UINT16(ctrlBlk.spare[0]);
    711            ENCDI = HI_UINT16(ctrlBlk.spare[0]);
    712            for (uint8 idx = 0; idx < 10; idx++)
    713            {
    714              ENCDI = ctrlBlk.nonce10[idx];
    715            }
    716          
    717            // Image length in 3 bytes, MSB to LSB order - the Signature bytes are not to be included.
    718            uint32 imageLen = 2048UL * ctrlBlk.imageLen - KEY_BLENGTH;
    719            ENCDI = ((uint8 *)&imageLen)[2];
    720            ENCDI = ((uint8 *)&imageLen)[1];
    721            ENCDI = ((uint8 *)&imageLen)[0];
    722          
    723            while ((ENCCS & BV(3)) == 0);
    724          }
    725          #endif
    726          
    727          /**************************************************************************************************
    728           * @fn          cntDnForcedDecr
    729           *
    730           * @brief       Decrement the cntDnForced.
    731           *
    732           * input parameters
    733           *
    734           * None.
    735           *
    736           * output parameters
    737           *
    738           * None.
    739           *
    740           * @return      TRUE if the dlyJmp decrements to zero; FALSE otherwise.
    741           */
    742          static bool cntDnForcedDecr(void)
    743          {
    744            uint8 mask = 0x01;
    745          
    746            while ((mask & ublMD.cntDnForced) == 0)
    747            {
    748              mask <<= 1;
    749            }
    750            ublMD.cntDnForced ^= mask;
    751          
    752            if (ublMD.cntDnForced == 0)
    753            {
    754              // Don't write the zero to flash in case of another cold-boot before re-programming, just
    755              // force boot now by faking the CRC-shdw as zeroed.
    756              ublMD.crcShdw = UBL_CRC_ZEROED;  // No need to zero crcShdw in flash, this will always run.
    757              return TRUE;
    758            }
    759            else
    760            {
    761              // This will write zero to exactly one bit, so no bit is written to zero twice.
    762              uint8 forcedAndPad[4] = { 0xFF, 0xFF, 0xFF, 0xFF };
    763              forcedAndPad[0] ^= mask;
    764              HalFlashWrite(UBL_CNTDN_FORCED_ADDR, forcedAndPad, 1);
    765              return FALSE;
    766            }
    767          }
    768          
    769          #if defined UBL_GPIO_USE
    770          /**************************************************************************************************
    771           * @fn          gpioInit
    772           *
    773           * @brief       Initialize the generic GPIO force configuration.
    774           *
    775           * input parameters
    776           *
    777           * None.
    778           *
    779           * output parameters
    780           *
    781           * None.
    782           *
    783           * @return      TRUE if the GPIO is already forcing UBL mode; FALSE otherwise.
    784           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    785          static bool gpioInit(void)
   \                     ??gpioInit:
    786          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    787            volatile uint8 *ptr;
    788            uint8 port = ublMD.gpioPort / 8;
   \   000005   90....       MOV     DPTR,#ublMD + 89
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F8           MOV     R0,A
   \   00000A   13           RRC     A
   \   00000B   13           RRC     A
   \   00000C   13           RRC     A
   \   00000D   541F         ANL     A,#0x1f
   \   00000F   F9           MOV     R1,A
    789            uint8 pin = ublMD.gpioPort % 8;
   \   000010   7407         MOV     A,#0x7
   \   000012   58           ANL     A,R0
   \   000013   FC           MOV     R4,A
    790          
    791            ptr = ((port == 0) ? &X_P0SEL : ((port == 1) ? &X_P1SEL : &X_P2SEL));
   \   000014   E9           MOV     A,R1
   \   000015   7004         JNZ     ??gpioInit_1
   \   000017   7AF3         MOV     R2,#-0xd
   \   000019   800B         SJMP    ??gpioInit_2
   \                     ??gpioInit_1:
   \   00001B   7401         MOV     A,#0x1
   \   00001D   69           XRL     A,R1
   \   00001E   7004         JNZ     ??gpioInit_3
   \   000020   7AF4         MOV     R2,#-0xc
   \   000022   8002         SJMP    ??gpioInit_2
   \                     ??gpioInit_3:
   \   000024   7AF5         MOV     R2,#-0xb
   \                     ??gpioInit_2:
   \   000026   7B70         MOV     R3,#0x70
    792            *ptr &= ~BV(pin);
   \   000028   EC           MOV     A,R4
   \   000029   F8           MOV     R0,A
   \   00002A   7401         MOV     A,#0x1
   \   00002C   B80002       CJNE    R0,#0x0,??gpioInit_4
   \   00002F   8004         SJMP    ??gpioInit_5
   \                     ??gpioInit_4:
   \   000031   C3           CLR     C
   \   000032   33           RLC     A
   \   000033   D8FC         DJNZ    R0,??gpioInit_4
   \                     ??gpioInit_5:
   \   000035   F8           MOV     R0,A
   \   000036   F4           CPL     A
   \   000037   FD           MOV     R5,A
   \   000038   8A82         MOV     DPL,R2
   \   00003A   8B83         MOV     DPH,R3
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   5D           ANL     A,R5
   \   00003E   F0           MOVX    @DPTR,A
    793          
    794            ptr = ((port == 0) ? &X_P0DIR : ((port == 1) ? &X_P1DIR : &X_P2DIR));
   \   00003F   E9           MOV     A,R1
   \   000040   7004         JNZ     ??gpioInit_6
   \   000042   7AFD         MOV     R2,#-0x3
   \   000044   800B         SJMP    ??gpioInit_7
   \                     ??gpioInit_6:
   \   000046   7401         MOV     A,#0x1
   \   000048   69           XRL     A,R1
   \   000049   7004         JNZ     ??gpioInit_8
   \   00004B   7AFE         MOV     R2,#-0x2
   \   00004D   8002         SJMP    ??gpioInit_7
   \                     ??gpioInit_8:
   \   00004F   7AFF         MOV     R2,#-0x1
    795            *ptr &= ~BV(pin);
   \                     ??gpioInit_7:
   \   000051   8A82         MOV     DPL,R2
   \   000053   E0           MOVX    A,@DPTR
   \   000054   5D           ANL     A,R5
   \   000055   F0           MOVX    @DPTR,A
    796          
    797            ptr = ((port == 0) ? &X_P0INP : ((port == 1) ? &X_P1INP : &X_P2INP));
   \   000056   E9           MOV     A,R1
   \   000057   7004         JNZ     ??gpioInit_9
   \   000059   7A8F         MOV     R2,#-0x71
   \   00005B   800B         SJMP    ??gpioInit_10
   \                     ??gpioInit_9:
   \   00005D   7401         MOV     A,#0x1
   \   00005F   69           XRL     A,R1
   \   000060   7004         JNZ     ??gpioInit_11
   \   000062   7AF6         MOV     R2,#-0xa
   \   000064   8002         SJMP    ??gpioInit_10
   \                     ??gpioInit_11:
   \   000066   7AF7         MOV     R2,#-0x9
    798            if (GET_BIT(ublMD.cfgDiscs+0, gpioPullTri))     // If pulling.
   \                     ??gpioInit_10:
   \   000068   90....       MOV     DPTR,#ublMD + 88
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   A2E2         MOV     C,0xE0 /* A   */.2
   \   00006E   5025         JNC     ??gpioInit_12
    799            {
    800              if (GET_BIT(ublMD.cfgDiscs+0, gpioPullUpDn))  // If pulling up.
   \   000070   75..01       MOV     ?V0,#0x1
   \   000073   75..00       MOV     ?V1,#0x0
   \   000076   7405         MOV     A,#0x5
   \   000078   29           ADD     A,R1
   \   000079   78..         MOV     R0,#?V0
   \   00007B   12....       LCALL   ?S_SHL
   \   00007E   A8..         MOV     R0,?V0
   \   000080   E0           MOVX    A,@DPTR
   \   000081   A2E3         MOV     C,0xE0 /* A   */.3
   \   000083   E8           MOV     A,R0
   \   000084   5005         JNC     ??gpioInit_13
    801              {
    802                P2INP &= ~BV(port + 5);
   \   000086   F4           CPL     A
   \   000087   52F7         ANL     0xf7,A
   \   000089   8002         SJMP    ??gpioInit_14
    803              }
    804              else                                          // If pulling down.
    805              {
    806                P2INP |= BV(port + 5); \
   \                     ??gpioInit_13:
   \   00008B   42F7         ORL     0xf7,A
    807              }
    808              *ptr &= ~BV(pin);
   \                     ??gpioInit_14:
   \   00008D   8A82         MOV     DPL,R2
   \   00008F   8B83         MOV     DPH,R3
   \   000091   E0           MOVX    A,@DPTR
   \   000092   5D           ANL     A,R5
   \   000093   8006         SJMP    ??gpioInit_15
    809            }
    810            else                                            // Tri-state.
    811            {
    812              *ptr |=  BV(pin);
   \                     ??gpioInit_12:
   \   000095   8A82         MOV     DPL,R2
   \   000097   8B83         MOV     DPH,R3
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   48           ORL     A,R0
   \                     ??gpioInit_15:
   \   00009B   F0           MOVX    @DPTR,A
    813            }
    814          
    815            forcePin = pin;
   \   00009C   EC           MOV     A,R4
   \   00009D   90....       MOV     DPTR,#??forcePin
   \   0000A0   F0           MOVX    @DPTR,A
    816            pForcePort = ((port == 0) ? &X_P0 : ((port == 1) ? &X_P1 : &X_P2));
   \   0000A1   E9           MOV     A,R1
   \   0000A2   7007         JNZ     ??gpioInit_16
   \   0000A4   90....       MOV     DPTR,#??pForcePort
   \   0000A7   7480         MOV     A,#-0x80
   \   0000A9   800E         SJMP    ??gpioInit_17
   \                     ??gpioInit_16:
   \   0000AB   7401         MOV     A,#0x1
   \   0000AD   69           XRL     A,R1
   \   0000AE   90....       MOV     DPTR,#??pForcePort
   \   0000B1   7004         JNZ     ??gpioInit_18
   \   0000B3   7490         MOV     A,#-0x70
   \   0000B5   8002         SJMP    ??gpioInit_17
   \                     ??gpioInit_18:
   \   0000B7   74A0         MOV     A,#-0x60
   \                     ??gpioInit_17:
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   7470         MOV     A,#0x70
   \   0000BD   F0           MOVX    @DPTR,A
    817          
    818            if (GET_BIT(ublMD.cfgDiscs+0, gpioPolarity) == ((*pForcePort & BV(forcePin)) != 0))
   \   0000BE   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000C1   C0E0         PUSH    A
   \   0000C3   90....       MOV     DPTR,#??forcePin
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   F8           MOV     R0,A
   \   0000C8   D0E0         POP     A
   \   0000CA   B80002       CJNE    R0,#0x0,??gpioInit_19
   \   0000CD   8004         SJMP    ??gpioInit_20
   \                     ??gpioInit_19:
   \   0000CF   C3           CLR     C
   \   0000D0   13           RRC     A
   \   0000D1   D8FC         DJNZ    R0,??gpioInit_19
   \                     ??gpioInit_20:
   \   0000D3   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000D5   92F0         MOV     B.0,C
   \   0000D7   90....       MOV     DPTR,#ublMD + 88
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   A2E1         MOV     C,0xE0 /* A   */.1
   \   0000DD   20F001       JB      B.0,??gpioInit_21
   \   0000E0   B3           CPL     C
   \                     ??gpioInit_21:
   \   0000E1   500B         JNC     ??gpioInit_22
    819            {
    820              ublMD.crcShdw = UBL_CRC_ZEROED;
   \   0000E3   90....       MOV     DPTR,#ublMD + 2
   \   0000E6   E4           CLR     A
   \   0000E7   F0           MOVX    @DPTR,A
   \   0000E8   A3           INC     DPTR
   \   0000E9   F0           MOVX    @DPTR,A
    821              return TRUE;
   \   0000EA   7901         MOV     R1,#0x1
   \   0000EC   8002         SJMP    ??gpioInit_23
    822            }
    823          
    824            return FALSE;
   \                     ??gpioInit_22:
   \   0000EE   7900         MOV     R1,#0x0
   \                     ??gpioInit_23:
   \   0000F0   80..         SJMP    ??Subroutine27_0
   \   0000F2                REQUIRE P2INP
    825          }
    826          #endif
    827          
    828          /**************************************************************************************************
    829           * @fn          vddWait
    830           *
    831           * @brief       Loop waiting for 16 reads of the Vdd over the safe minimum to erase/write flash.
    832           *
    833           * input parameters
    834           *
    835           * None.
    836           *
    837           * output parameters
    838           *
    839           * None.
    840           *
    841           * @return      None.
    842           */
    843          static void vddWait(void)
    844          {
    845            uint8 cnt = 16;
    846          
    847            do {
    848              do {
    849                ADCCON3 = 0x0F;
    850                while (!(ADCCON1 & 0x80));
    851              } while (ADCH < VDD_MIN_NV);
    852            } while (--cnt);
    853          }
    854          
    855          /**************************************************************************************************
    856          */
E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_main.c
      1          /**************************************************************************************************
      2            Filename:       ubl_main.c
      3            Revised:        $Date: 2012-09-12 10:59:31 -0700 (Wed, 12 Sep 2012) $
      4            Revision:       $Revision: 31516 $
      5          
      6            Description:
      7          
      8            This module implements the main functionality of a Universal Boot Loader for an 8051-based SOC
      9            via the USB by MSD. The functionality is similar to ZStack OnBoard.c and hal_startup.c.
     10          
     11          
     12            Copyright 2011-2012 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights
     15            granted under the terms of a software license agreement between the user
     16            who downloaded the software, his/her employer (which must be your employer)
     17            and Texas Instruments Incorporated (the "License").  You may not use this
     18            Software unless you agree to abide by the terms of the License. The License
     19            limits your use, and you acknowledge, that the Software may not be modified,
     20            copied or distributed unless embedded on a Texas Instruments microcontroller
     21            or used solely and exclusively in conjunction with a Texas Instruments radio
     22            frequency transceiver, which is integrated into your product.  Other than for
     23            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     24            works of, modify, distribute, perform, display or sell this Software and/or
     25            its documentation for any purpose.
     26          
     27            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     28            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     29            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     30            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     31            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     32            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     33            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     34            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     35            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     36            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     37            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     38          
     39            Should you have any questions regarding your right to use this Software,
     40            contact Texas Instruments Incorporated at www.TI.com.
     41          **************************************************************************************************/
     42          
     43          /* ------------------------------------------------------------------------------------------------
     44           *                                          Includes
     45           * ------------------------------------------------------------------------------------------------
     46           */
     47          
     48          #include "hal_board_cfg.h"
     49          #include "hal_dma.h"
     50          #include "hal_flash.h"
     51          #include "ubl_app.h"
     52          #include "ubl_exec.h"
     53          #include "usb_interrupt.h"
     54          
     55          /* ------------------------------------------------------------------------------------------------
     56           *                                       Global Variables
     57           * ------------------------------------------------------------------------------------------------
     58           */
     59          

   \                                 In  segment XDATA_N, align 1
     60          __no_init halDMADesc_t dmaCh0;  // Needed by the HAL flash write.
   \                     dmaCh0:
   \   000000                DS 8
     61          
     62          /* ------------------------------------------------------------------------------------------------
     63           *                                       Local Functions
     64           * ------------------------------------------------------------------------------------------------
     65           */
     66          
     67          static void vddWait(void);
     68          
     69          // If the code model is banked, low_level_init must be declared
     70          // __near_func elsa a ?BRET is performed
     71          //
     72          #if (__CODE_MODEL__ == 2)
     73          __near_func __root char
     74          #else
     75          __root char
     76          #endif
     77          __low_level_init(void);
     78          
     79          /**************************************************************************************************
     80           * @fn          __low_level_init
     81           *
     82           * @brief       Abort boot loader as soon as possible after a Watchdog reset with a valid RC image.
     83           *              This function is called by the IAR start-up code before doing normal initialization
     84           *              of the data segments.
     85           *
     86           * input parameters
     87           *
     88           * None.
     89           *
     90           * output parameters
     91           *
     92           * None.
     93           *
     94           * @return      0 - don't intialize data segments / 1 - do initialization.
     95           */
     96          #if (__CODE_MODEL__ == 2)

   \                                 In  segment NEAR_CODE, align 1, keep-with-next, root
     97          __near_func __root char
     98          #else
     99          __root char
    100          #endif
    101          __low_level_init(void)
   \                     __low_level_init:
   \   000000                REQUIRE __low_level_init_call
    102          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    103            // Map flash bank #7 into XDATA for access to "ROM mapped as data".
    104            MEMCTR = (MEMCTR & 0xF8) | 0x07;
   \   000005   43C707       ORL     0xc7,#0x7
    105          
    106            if (ResetWasWatchDog)
   \   000008   E59D         MOV     A,0x9d
   \   00000A   5418         ANL     A,#0x18
   \   00000C   6410         XRL     A,#0x10
   \   00000E   7042         JNZ     ??__low_level_init_0
    107            {
    108              // Read from Flash the minimum subset of ublMetaData_t necessary for UBL_RC_VALID().
    109              HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD.crcRC, 4);
   \   000010                ; Setup parameters for call to function HalFlashRead
   \   000010   75..04       MOV     ?V0,#0x4
   \   000013   75..00       MOV     ?V1,#0x0
   \   000016   78..         MOV     R0,#?V0
   \   000018   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001B   7C..         MOV     R4,#ublMD & 0xff
   \   00001D   7D..         MOV     R5,#(ublMD >> 8) & 0xff
   \   00001F   7A9C         MOV     R2,#-0x64
   \   000021   7B06         MOV     R3,#0x6
   \   000023   7901         MOV     R1,#0x1
   \   000025   12....       LCALL   ??HalFlashRead?relay ; Banked call to: HalFlashRead
   \   000028   7402         MOV     A,#0x2
   \   00002A   12....       LCALL   ?DEALLOC_XSTACK8
    110          
    111              if (UBL_RC_VALID)
   \   00002D   90....       MOV     DPTR,#ublMD
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F8           MOV     R0,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F9           MOV     R1,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   68           XRL     A,R0
   \   000038   7003         JNZ     ??__low_level_init_1
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   69           XRL     A,R1
   \                     ??__low_level_init_1:
   \   00003D   7013         JNZ     ??__low_level_init_0
   \   00003F   90....       MOV     DPTR,#ublMD
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F4           CPL     A
   \   000044   7003         JNZ     ??__low_level_init_2
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F4           CPL     A
   \                     ??__low_level_init_2:
   \   000049   6007         JZ      ??__low_level_init_0
   \   00004B   E8           MOV     A,R0
   \   00004C   49           ORL     A,R1
   \   00004D   6003         JZ      ??__low_level_init_0
    112              {
    113                ublJump();
   \   00004F                ; Setup parameters for call to function ublJump
   \   00004F   12....       LCALL   ??ublJump?relay      ; Banked call to: ublJump
    114              }
    115            }
    116          
    117            vddWait();
   \                     ??__low_level_init_0:
   \   000052   7810         MOV     R0,#0x10
   \                     ??__low_level_init_3:
   \   000054   75B60F       MOV     0xb6,#0xf
   \                     ??__low_level_init_4:
   \   000057   E5B4         MOV     A,0xb4
   \   000059   A2E7         MOV     C,0xE0 /* A   */.7
   \   00005B   50FA         JNC     ??__low_level_init_4
   \   00005D   E5BB         MOV     A,0xbb
   \   00005F   C3           CLR     C
   \   000060   944A         SUBB    A,#0x4a
   \   000062   40F0         JC      ??__low_level_init_3
   \   000064   18           DEC     R0
   \   000065   E8           MOV     A,R0
   \   000066   70EC         JNZ     ??__low_level_init_3
    118            HAL_BOARD_INIT();
   \   000068   75A800       MOV     0xa8,#0x0
   \   00006B   75B800       MOV     0xb8,#0x0
   \   00006E   759A00       MOV     0x9a,#0x0
   \   000071   75C680       MOV     0xc6,#-0x80
   \   000074   906270       MOV     DPTR,#0x6270
   \   000077   7408         MOV     A,#0x8
   \   000079   F0           MOVX    @DPTR,A
    119          
    120            // Choose if segment initialization should be done or not: 0 to omit seg_init; 1 to run seg_init.
    121            return 1;
   \   00007A   7901         MOV     R1,#0x1
   \   00007C   7F02         MOV     R7,#0x2
   \   00007E   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000081                REQUIRE MEMCTR
   \   000081                REQUIRE SLEEPSTA
   \   000081                REQUIRE _A_IEN0
   \   000081                REQUIRE _A_IEN1
   \   000081                REQUIRE IEN2
   \   000081                REQUIRE CLKCONCMD
   \   000081                REQUIRE ADCCON3
   \   000081                REQUIRE ADCCON1
   \   000081                REQUIRE ADCH
    122          }
    123          
    124          /**************************************************************************************************
    125           * @fn          main
    126           *
    127           * @brief       ISR for the reset vector, invoked by IAR after all segment initialization.
    128           *
    129           * input parameters
    130           *
    131           * None.
    132           *
    133           * output parameters
    134           *
    135           * None.
    136           *
    137           * @return      None.
    138           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    139          void main(void)
   \                     main:
    140          {
   \   000000                ; Auto size: 0
    141            /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
    142             * descriptors in addition to just Channel 0.
    143             */
    144            HAL_DMA_SET_ADDR_DESC0(&dmaCh0);
   \   000000   74..         MOV     A,#(dmaCh0 >> 8) & 0xff
   \   000002   F5D5         MOV     0xd5,A
   \   000004   75D4..       MOV     0xd4,#dmaCh0 & 0xff
    145          
    146            ublInit();
   \   000007                ; Setup parameters for call to function ublInit
   \   000007   12....       LCALL   ??ublInit?relay      ; Banked call to: ublInit
    147            ublExec();
   \   00000A                ; Setup parameters for call to function ublExec
   \   00000A   12....       LCALL   ??ublExec?relay      ; Banked call to: ublExec
    148          
    149            HAL_SYSTEM_RESET();
   \   00000D   C2AF         CLR     0xa8.7
   \   00000F   75C9AB       MOV     0xc9,#-0x55
   \   000012   75C95B       MOV     0xc9,#0x5b
   \                     ??main_0:
   \   000015   80FE         SJMP    ??main_0
   \   000017                REQUIRE DMA0CFGH
   \   000017                REQUIRE DMA0CFGL
   \   000017                REQUIRE _A_IEN0
   \   000017                REQUIRE WDCTL
    150          }
    151          
    152          /**************************************************************************************************
    153           * @fn          vddWait
    154           *
    155           * @brief       Loop waiting for 16 reads of the Vdd over the safe minimum to run.
    156           *
    157           * input parameters
    158           *
    159           * None.
    160           *
    161           * output parameters
    162           *
    163           * None.
    164           *
    165           * @return      None.
    166           */
    167          static void vddWait(void)
    168          {
    169            uint8 cnt = 16;
    170          
    171            do {
    172              do {
    173                ADCCON3 = 0x0F;
    174                while (!(ADCCON1 & 0x80));
    175              } while (ADCH < VDD_MIN_RUN);
    176            } while (--cnt);
    177          }
    178          
    179          /**************************************************************************************************
    180          */
E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_descriptor_parser.c
      1          /***********************************************************************************
      2          
      3              Filename:     usb_descriptor_parser.c
      4          
      5              Description:  Parser for USB descriptor structures.
      6          
      7          ***********************************************************************************/
      8          
      9          /// \addtogroup module_usb_descriptor_parser
     10          /// @{
     11          #define USBDESCRIPTORPARSER_C ///< Modifies the behavior of "EXTERN" in usb_descriptor_parser.h
     12          #include "usb_firmware_library_headers.h"
     13          #include "hal_flash.h"
     14          
     15          //-------------------------------------------------------------------------------------------------------
     16          // USBDP internal module data

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     17          static USBDP_DATA __xdata usbdpData; ///< USBDP internal module data
   \                     ??usbdpData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     18          
     19          //-------------------------------------------------------------------------------------------------------
     20          // String descriptors (2-byte unicode data).
     21          
     22          // Language ID.

   \                                 In  segment XDATA_ROM_C, align 1
     23          static const uint8 languageId[4] = {
   \                     ??languageId:
   \   000000   04           DB 4
   \   000001   03           DB 3
   \   000002   09           DB 9
   \   000003   04           DB 4
     24            4,
     25            DESC_TYPE_STRING,
     26            0x09, 0x04  /* US-EN */
     27          };
     28          
     29          // Manufacturer.

   \                                 In  segment XDATA_ROM_C, align 1
     30          static const uint8 manufacturer[36] = {
   \                     ??manufacturer:
   \   000000   24           DB 36
   \   000001   03           DB 3
   \   000002   54           DB 84
   \   000003   00           DB 0
   \   000004   65           DB 101
   \   000005   00           DB 0
   \   000006   78           DB 120
   \   000007   00           DB 0
   \   000008   61           DB 97
   \   000009   00           DB 0
   \   00000A   73           DB 115
   \   00000B   00           DB 0
   \   00000C   20           DB 32
   \   00000D   00           DB 0
   \   00000E   49           DB 73
   \   00000F   00           DB 0
   \   000010   6E           DB 110
   \   000011   00           DB 0
   \   000012   73           DB 115
   \   000013   00           DB 0
   \   000014   74           DB 116
   \   000015   00           DB 0
   \   000016   72           DB 114
   \   000017   00           DB 0
   \   000018   75           DB 117
   \   000019   00           DB 0
   \   00001A   6D           DB 109
   \   00001B   00           DB 0
   \   00001C   65           DB 101
   \   00001D   00           DB 0
   \   00001E   6E           DB 110
   \   00001F   00           DB 0
   \   000020   74           DB 116
   \   000021   00           DB 0
   \   000022   73           DB 115
   \   000023   00           DB 0
     31            36,
     32            DESC_TYPE_STRING,
     33            'T', 0,
     34            'e', 0,
     35            'x', 0,
     36            'a', 0,
     37            's', 0,
     38            ' ', 0,
     39            'I', 0,
     40            'n', 0,
     41            's', 0,
     42            't', 0,
     43            'r', 0,
     44            'u', 0,
     45            'm', 0,
     46            'e', 0,
     47            'n', 0,
     48            't', 0,
     49            's', 0
     50          };
     51          
     52          // Product.
     53          #if defined HAL_SB_BOOT_CODE

   \                                 In  segment XDATA_ROM_C, align 1
     54          static const uint8 product[36] = {
   \                     ??product:
   \   000000   24           DB 36
   \   000001   03           DB 3
   \   000002   54           DB 84
   \   000003   00           DB 0
   \   000004   49           DB 73
   \   000005   00           DB 0
   \   000006   20           DB 32
   \   000007   00           DB 0
   \   000008   43           DB 67
   \   000009   00           DB 0
   \   00000A   43           DB 67
   \   00000B   00           DB 0
   \   00000C   32           DB 50
   \   00000D   00           DB 0
   \   00000E   35           DB 53
   \   00000F   00           DB 0
   \   000010   33           DB 51
   \   000011   00           DB 0
   \   000012   31           DB 49
   \   000013   00           DB 0
   \   000014   20           DB 32
   \   000015   00           DB 0
   \   000016   55           DB 85
   \   000017   00           DB 0
   \   000018   53           DB 83
   \   000019   00           DB 0
   \   00001A   42           DB 66
   \   00001B   00           DB 0
   \   00001C   20           DB 32
   \   00001D   00           DB 0
   \   00001E   4D           DB 77
   \   00001F   00           DB 0
   \   000020   53           DB 83
   \   000021   00           DB 0
   \   000022   44           DB 68
   \   000023   00           DB 0
     55            36,
     56            DESC_TYPE_STRING,
     57            'T', 0,
     58            'I', 0,
     59            ' ', 0,
     60            'C', 0,
     61            'C', 0,
     62            '2', 0,
     63            '5', 0,
     64            '3', 0,
     65            '1', 0,
     66            ' ', 0,
     67            'U', 0,
     68            'S', 0,
     69            'B', 0,
     70            ' ', 0,
     71            'M', 0,
     72            'S', 0,
     73            'D', 0
     74          };
     75          #else
     76          static const uint8 product[36] = {
     77            36,
     78            DESC_TYPE_STRING,
     79            'T', 0,
     80            'I', 0,
     81            ' ', 0,
     82            'C', 0,
     83            'C', 0,
     84            '2', 0,
     85            '5', 0,
     86            '3', 0,
     87            '1', 0,
     88            ' ', 0,
     89            'U', 0,
     90            'S', 0,
     91            'B', 0,
     92            ' ', 0,
     93            'C', 0,
     94            'D', 0,
     95            'C', 0
     96          };
     97          #endif
     98          
     99          // Serial Number.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    100          static uint8 serialNumber[42] = {
   \                     ??serialNumber:
   \   000000                DS 42
   \   00002A                REQUIRE `?<Initializer for serialNumber>`
   \   00002A                REQUIRE __INIT_XDATA_I
    101            0,  // Initializing to zero vice 42 is the indication to usbdpGetStringDesc() to fill w/ IEEE.
    102            DESC_TYPE_STRING,
    103            // Setup for using the 16 nibbles of the hex representation of the IEEE address.
    104            '_', 0,
    105            '_', 0,
    106            '0', 0,
    107            'X', 0,
    108          };
    109          

   \                                 In  segment XDATA_ROM_C, align 1
    110          const uint8 hexDigit[16] = {
   \                     hexDigit:
   \   000000   30           DB 48
   \   000001   31           DB 49
   \   000002   32           DB 50
   \   000003   33           DB 51
   \   000004   34           DB 52
   \   000005   35           DB 53
   \   000006   36           DB 54
   \   000007   37           DB 55
   \   000008   38           DB 56
   \   000009   39           DB 57
   \   00000A   41           DB 65
   \   00000B   42           DB 66
   \   00000C   43           DB 67
   \   00000D   44           DB 68
   \   00000E   45           DB 69
   \   00000F   46           DB 70
    111            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
    112          
    113          /** \brief	Initializes a search
    114          *
    115          * This function must be called before each new search to reset \ref USBDP_DATA.pDesc.
    116          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    117          void usbdpInit(void)
   \                     usbdpInit:
    118          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    119             usbdpData.pDesc = (const uint8 __code *) usbDescriptorMarker.pUsbDescStart;
   \   000004   90....       MOV     DPTR,#usbDescriptorMarker
   \   000007   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00000A   90....       MOV     DPTR,#??usbdpData
   \   00000D   E8           MOV     A,R0
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   E9           MOV     A,R1
   \   000011   02....       LJMP    ??Subroutine29_0 & 0xFFFF
    120          } // usbdpInit
    121          
    122          
    123          
    124          
    125          /** \brief	Locates the descriptor of the wanted type
    126          *
    127          * This function parses through the USB descriptors until:
    128          * \li It hits one with <tt>bDescriptorType = wantedType</tt>, in which case it returns a pointer to
    129          *     that descriptor, and exits. \ref USBDP_DATA.pDesc will then point to the next descriptor.
    130          * \li It hits one with <tt>bDescriptorType = haltAtType</tt>, in which case it returns a NULL-pointer,
    131          *     and exits. \ref USBDP_DATA.pDesc will then point to that descriptor.
    132          * \li \ref USBDP_DATA.pDesc = \ref usbDescEnd, in which case it returns a NULL-pointer, and exits.
    133          *     \ref USBDP_DATA.pDesc will continue to point to \ref usbDescEnd.
    134          *
    135          * \note To begin a search with this function, \ref usbdpInit should be called first. It should not be
    136          *       called when continuing a search - for instance after a call to \ref usbdpGetConfigurationDesc().
    137          *
    138          * \param[in]       wantedType
    139          *     The wanted descriptor type (e.g. \ref DESC_TYPE_CONFIG)
    140          * \param[in]       haltAtType
    141          *     The parser halts when it reaches this descriptor type, unless \c haltAtType is \c 0 (which in any
    142          *     case is an invalid \c bDescriptorType value).
    143          *
    144          * \return
    145          *     A pointer to the wanted descriptor type, or \c NULL if it was not found.
    146          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    147          void __code* usbdpFindNext(uint8 wantedType, uint8 haltAtType)
   \                     usbdpFindNext:
    148          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   FC           MOV     R4,A
   \   000006   EA           MOV     A,R2
   \   000007   FD           MOV     R5,A
    149             void __code *pResult;
    150             pResult = NULL;
   \   000008   7A00         MOV     R2,#0x0
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   8003         SJMP    ??CrossCallReturnLabel_2
    151          
    152             // As long as we haven't reached the end...
    153             while (usbdpData.pDesc != (void __code *) usbDescriptorMarker.pUsbDescEnd) {
    154          
    155                // If we have a match on wantedType...
    156                if (usbdpData.pDesc[DESC_TYPE_IDX] == wantedType) {
    157                   pResult = (void __code*) usbdpData.pDesc;
    158                   usbdpData.pDesc += usbdpData.pDesc[DESC_LENGTH_IDX];
    159                   break;
    160          
    161                // If we have a match on haltAtType...
    162                } else if (usbdpData.pDesc[DESC_TYPE_IDX] == haltAtType) {
    163                   if (haltAtType) break;
    164                }
    165          
    166                // Move on to the next descriptor
    167                usbdpData.pDesc += usbdpData.pDesc[DESC_LENGTH_IDX];
   \                     ??usbdpFindNext_0:
   \   00000E   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000011   90....       MOV     DPTR,#??usbdpData
   \   000014   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000017   90....       MOV     DPTR,#usbDescriptorMarker + 2
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   68           XRL     A,R0
   \   00001C   7003         JNZ     ??usbdpFindNext_1
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   69           XRL     A,R1
   \                     ??usbdpFindNext_1:
   \   000021   6022         JZ      ??usbdpFindNext_2
   \   000023   90....       MOV     DPTR,#??usbdpData + 1
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F583         MOV     DPH,A
   \   000029   8882         MOV     DPL,R0
   \   00002B   A3           INC     DPTR
   \   00002C   E4           CLR     A
   \   00002D   93           MOVC    A,@A+DPTR
   \   00002E   F8           MOV     R0,A
   \   00002F   EC           MOV     A,R4
   \   000030   68           XRL     A,R0
   \   000031   700B         JNZ     ??usbdpFindNext_3
   \   000033   90....       MOV     DPTR,#??usbdpData
   \   000036   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000039   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00003C   8007         SJMP    ??usbdpFindNext_2
   \                     ??usbdpFindNext_3:
   \   00003E   ED           MOV     A,R5
   \   00003F   68           XRL     A,R0
   \   000040   70CC         JNZ     ??usbdpFindNext_0
   \   000042   ED           MOV     A,R5
   \   000043   60C9         JZ      ??usbdpFindNext_0
    168             }
    169          
    170             return pResult;
   \                     ??usbdpFindNext_2:
   \   000045   80..         SJMP    ??Subroutine30_0
    171          } // usbdpFindNext

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   90....       MOV     DPTR,#??usbdpData
   \   000003   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000006   E4           CLR     A
   \   000007   93           MOVC    A,@A+DPTR
   \   000008   F8           MOV     R0,A
   \   000009   90....       MOV     DPTR,#??usbdpData
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   28           ADD     A,R0
   \   00000E   F8           MOV     R0,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   3400         ADDC    A,#0x0
   \   000013   F9           MOV     R1,A
   \   000014   90....       MOV     DPTR,#??usbdpData
   \   000017   E8           MOV     A,R0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   E9           MOV     A,R1
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   22           RET
    172          
    173          
    174          
    175          
    176          /** \brief	Locates the (one and only) device descriptor
    177          *
    178          * \note It is not necessary to call \ref usbdpInit() before this function.
    179          *
    180          * \return
    181          *     A pointer to the \ref USB_DEVICE_DESCRIPTOR, or \c NULL if it was not found.
    182          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    183          USB_DEVICE_DESCRIPTOR __code* usbdpGetDeviceDesc(void)
   \                     usbdpGetDeviceDesc:
    184          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    185             usbdpInit();
   \   000004   12....       LCALL   ?Subroutine11 & 0xFFFF
    186             return usbdpFindNext(DESC_TYPE_DEVICE, 0);
   \                     ??CrossCallReturnLabel_7:
   \   000007                ; Setup parameters for call to function usbdpFindNext
   \   000007   7A00         MOV     R2,#0x0
   \   000009   7901         MOV     R1,#0x1
   \   00000B   12....       LCALL   ??usbdpFindNext?relay; Banked call to: usbdpFindNext
   \   00000E   80..         SJMP    ??Subroutine30_0
    187          } // usbdpGetDeviceDesc
    188          
    189          
    190          
    191          
    192          /** \brief	Locates a configuration descriptor
    193          *
    194          * The search will either look for a descriptor with a specific
    195          * \ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue, or simply take the n'th descriptor (by "index")
    196          *
    197          * \note It is not necessary to call \ref usbdpInit() before this function.
    198          *
    199          * \param[in]       cfgValue
    200          *     The configuration value to search for (\ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue), or
    201          *     0 to find descriptor by index
    202          * \param[in]       cfgIndex
    203          *     A zero-based index for the configuration descriptor to find.
    204          *     This value is ignored unless \c cfgValue is 0.
    205          *
    206          * \return
    207          *     A pointer to the \ref USB_DEVICE_DESCRIPTOR, or \c NULL if it was not found.
    208          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    209          USB_CONFIGURATION_DESCRIPTOR __code* usbdpGetConfigurationDesc(uint8 cfgValue, uint8 cfgIndex)
   \                     usbdpGetConfigurationDesc:
    210          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FF           MOV     R7,A
    211             USB_CONFIGURATION_DESCRIPTOR __code *pConfigurationDesc;
    212             usbdpInit();
   \   000009   12....       LCALL   ?Subroutine11 & 0xFFFF
    213          
    214             // As long as there are more configuration descriptors...
    215             while (pConfigurationDesc = usbdpFindNext(DESC_TYPE_CONFIG, 0)) {
   \                     ??CrossCallReturnLabel_8:
   \   00000C                ; Setup parameters for call to function usbdpFindNext
   \   00000C   7A00         MOV     R2,#0x0
   \   00000E   7902         MOV     R1,#0x2
   \   000010   12....       LCALL   ??usbdpFindNext?relay; Banked call to: usbdpFindNext
   \   000013   EA           MOV     A,R2
   \   000014   4B           ORL     A,R3
   \   000015   601C         JZ      ??usbdpGetConfigurationDesc_0
    216          
    217                // Search by value?
    218                if (cfgValue) {
   \   000017   EE           MOV     A,R6
   \   000018   6010         JZ      ??usbdpGetConfigurationDesc_1
    219                   if (cfgValue == pConfigurationDesc->bConfigurationValue) break;
   \   00001A   8A82         MOV     DPL,R2
   \   00001C   8B83         MOV     DPH,R3
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E4           CLR     A
   \   000024   93           MOVC    A,@A+DPTR
   \   000025   6E           XRL     A,R6
   \   000026   70E4         JNZ     ??CrossCallReturnLabel_8
   \   000028   8009         SJMP    ??usbdpGetConfigurationDesc_0
    220          
    221                // Search by index? (search cfgIndex+1 times)
    222                } else if (!cfgIndex--) {
   \                     ??usbdpGetConfigurationDesc_1:
   \   00002A   EF           MOV     A,R7
   \   00002B   F8           MOV     R0,A
   \   00002C   74FF         MOV     A,#-0x1
   \   00002E   28           ADD     A,R0
   \   00002F   1F           DEC     R7
   \   000030   04           INC     A
   \   000031   70D9         JNZ     ??CrossCallReturnLabel_8
    223                   break;
    224                }
    225             }
    226          
    227             return pConfigurationDesc;
   \                     ??usbdpGetConfigurationDesc_0:
   \   000033   02....       LJMP    ??Subroutine27_0 & 0xFFFF
    228          } // usbdpGetConfigurationDesc
    229          
    230          
    231          
    232          
    233          /** \brief	Locates an interface descriptor
    234          *
    235          * The function will first go to the configuration descriptor that matches the supplied configuration
    236          * value, and then locate the interface descriptor that matches the given interface number and alternate
    237          * setting.
    238          *
    239          * \note It is not necessary to call \ref usbdpInit() before this function.
    240          *
    241          * \param[in]       cfgValue
    242          *     The configuration value (\ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue)
    243          * \param[in]       intNumber
    244          *     The interface number (\ref USB_INTERFACE_DESCRIPTOR.bInterfaceNumber)
    245          * \param[in]       altSetting
    246          *     The alternate setting (\ref USB_INTERFACE_DESCRIPTOR.bAlternateSetting)
    247          *
    248          * \return
    249          *     A pointer to the \ref USB_INTERFACE_DESCRIPTOR, or \c NULL if it was not found.
    250          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    251          USB_INTERFACE_DESCRIPTOR __code* usbdpGetInterfaceDesc(uint8 cfgValue, uint8 intNumber, uint8 altSetting)
   \                     usbdpGetInterfaceDesc:
    252          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FF           MOV     R7,A
   \   000007   8B..         MOV     ?V0,R3
    253             USB_INTERFACE_DESCRIPTOR __code *pInterfaceDesc;
    254          
    255             // First get to the correct configuration
    256             usbdpGetConfigurationDesc(cfgValue, 0);
   \   000009                ; Setup parameters for call to function usbdpGetConfigurationDesc
   \   000009   7A00         MOV     R2,#0x0
   \   00000B   12....       LCALL   ??usbdpGetConfigurationDesc?relay; Banked call to: usbdpGetConfigurationDesc
    257          
    258             // Then find a match on the interface
    259             while (pInterfaceDesc = usbdpFindNext(DESC_TYPE_INTERFACE, DESC_TYPE_CONFIG)) {
   \                     ??usbdpGetInterfaceDesc_0:
   \   00000E                ; Setup parameters for call to function usbdpFindNext
   \   00000E   7A02         MOV     R2,#0x2
   \   000010   7904         MOV     R1,#0x4
   \   000012   12....       LCALL   ??usbdpFindNext?relay; Banked call to: usbdpFindNext
   \   000015   EA           MOV     A,R2
   \   000016   4B           ORL     A,R3
   \   000017   6018         JZ      ??usbdpGetInterfaceDesc_1
    260                if ((pInterfaceDesc->bInterfaceNumber == intNumber) && (pInterfaceDesc->bAlternateSetting == altSetting)) {
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E4           CLR     A
   \   000020   93           MOVC    A,@A+DPTR
   \   000021   6F           XRL     A,R7
   \   000022   70EA         JNZ     ??usbdpGetInterfaceDesc_0
   \   000024   8A82         MOV     DPL,R2
   \   000026   8B83         MOV     DPH,R3
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   E4           CLR     A
   \   00002C   93           MOVC    A,@A+DPTR
   \   00002D   65..         XRL     A,?V0
   \   00002F   70DD         JNZ     ??usbdpGetInterfaceDesc_0
    261                   break;
    262                }
    263             }
    264          
    265             return pInterfaceDesc;
   \                     ??usbdpGetInterfaceDesc_1:
   \   000031                REQUIRE ?Subroutine0
   \   000031                ; // Fall through to label ?Subroutine0
    266          } // usbdpGetInterfaceDesc
    267          
    268          
    269          
    270          
    271          /** \brief	Locates a string descriptor
    272          *
    273          * \note It is not necessary to call \ref usbdpInit() before this function.
    274          *
    275          * \param[in]       strIndex
    276          *     A zero-based index that matches the "iXxxxxxxxxx" string indexes in the other descriptors
    277          *
    278          * \return
    279          *     A pointer to the \ref USB_INTERFACE_DESCRIPTOR, or \c NULL if it was not found.
    280          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    281          USB_STRING_DESCRIPTOR* usbdpGetStringDesc(uint8 strIndex)
   \                     usbdpGetStringDesc:
    282          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
    283            USB_STRING_DESCRIPTOR *pStringDesc = NULL;
   \   00000B   7A00         MOV     R2,#0x0
   \   00000D   7B00         MOV     R3,#0x0
    284          
    285          #ifdef MS_EXT_C_ID
    286            /* TODO: Find the Microsoft OS String Descriptor?
    287            usbdpInit();
    288          
    289            if (strIndex == 0xEE){
    290              // Find the Microsoft OS String Descriptor
    291              do{
    292                pStringDesc = usbdpFindNext(DESC_TYPE_STRING, 0);
    293              }while (pStringDesc != NULL && pStringDesc->bLength != 18);
    294            } else
    295            */
    296          #endif
    297            {
    298              switch (strIndex)
   \   00000F   600B         JZ      ??usbdpGetStringDesc_0
   \   000011   14           DEC     A
   \   000012   600E         JZ      ??usbdpGetStringDesc_1
   \   000014   14           DEC     A
   \   000015   6011         JZ      ??usbdpGetStringDesc_2
   \   000017   14           DEC     A
   \   000018   6014         JZ      ??usbdpGetStringDesc_3
   \   00001A   8073         SJMP    ??usbdpGetStringDesc_4
    299              {
    300              case 0:
    301                pStringDesc = (USB_STRING_DESCRIPTOR *)languageId;
   \                     ??usbdpGetStringDesc_0:
   \   00001C   7A..         MOV     R2,#??languageId & 0xff
   \   00001E   7B..         MOV     R3,#(??languageId >> 8) & 0xff
    302                break;
   \   000020   806D         SJMP    ??usbdpGetStringDesc_4
    303          
    304              case 1:
    305                pStringDesc = (USB_STRING_DESCRIPTOR *)manufacturer;
   \                     ??usbdpGetStringDesc_1:
   \   000022   7A..         MOV     R2,#??manufacturer & 0xff
   \   000024   7B..         MOV     R3,#(??manufacturer >> 8) & 0xff
    306                break;
   \   000026   8067         SJMP    ??usbdpGetStringDesc_4
    307          
    308              case 2:
    309                pStringDesc = (USB_STRING_DESCRIPTOR *)product;
   \                     ??usbdpGetStringDesc_2:
   \   000028   7A..         MOV     R2,#??product & 0xff
   \   00002A   7B..         MOV     R3,#(??product >> 8) & 0xff
    310                break;
   \   00002C   8061         SJMP    ??usbdpGetStringDesc_4
    311          
    312              case 3:
    313                if (serialNumber[0] == 0)
   \                     ??usbdpGetStringDesc_3:
   \   00002E   90....       MOV     DPTR,#??serialNumber
   \   000031   E0           MOVX    A,@DPTR
   \   000032   7057         JNZ     ??usbdpGetStringDesc_5
    314                {
    315          #if (defined HAL_SB_BOOT_CODE || defined CC253X_MACNP || defined CC2531DK)
    316                  #include <string.h>
    317                  uint8 aExtendedAddress[HAL_FLASH_IEEE_SIZE] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
   \   000034   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,`
   \   000037   AC..         MOV     R4,?XSP + 0
   \   000039   AD..         MOV     R5,?XSP + 1
   \   00003B   7408         MOV     A,#0x8
   \   00003D   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    318                  /*
    319                  uint8 nullAddr[HAL_FLASH_IEEE_SIZE] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    320                  uint8 aExtendedAddress[HAL_FLASH_IEEE_SIZE];
    321          
    322                  // Attempt to read the extended address from the location on the lock bits page
    323                  // where the programming tools know to reserve it.
    324                  HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_IEEE_OSET,
    325                                  aExtendedAddress, HAL_FLASH_IEEE_SIZE);
    326          
    327                  if (!memcmp(aExtendedAddress, nullAddr, HAL_FLASH_IEEE_SIZE))
    328                  {
    329                    // Attempt to read the extended address from the designated location in the Info Page.
    330                    memcpy(aExtendedAddress, (uint8 *)(P_INFOPAGE+HAL_INFOP_IEEE_OSET), HAL_FLASH_IEEE_SIZE);
    331                  }
    332                   */
    333          #endif
    334                  // Load the 16 nibbles of the hex representation of the IEEE address into the serialNumber
    335                  // string in big-endian (i.e. human-readable) order.
    336                  for (uint8 idx = sizeof(serialNumber)-2, cnt=0; cnt < HAL_FLASH_IEEE_SIZE; cnt++, idx -= 4)
   \   000040   7C28         MOV     R4,#0x28
   \   000042   FD           MOV     R5,A
    337                  {
    338                    serialNumber[idx]   = hexDigit[aExtendedAddress[cnt] & 0x0F];
   \                     ??usbdpGetStringDesc_6:
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   E582         MOV     A,DPL
   \   00004B   2D           ADD     A,R5
   \   00004C   F582         MOV     DPL,A
   \   00004E   E4           CLR     A
   \   00004F   3583         ADDC    A,DPH
   \   000051   F583         MOV     DPH,A
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FF           MOV     R7,A
   \   000055   74..         MOV     A,#??serialNumber & 0xff
   \   000057   2C           ADD     A,R4
   \   000058   F8           MOV     R0,A
   \   000059   E4           CLR     A
   \   00005A   34..         ADDC    A,#(??serialNumber >> 8) & 0xff
   \   00005C   F9           MOV     R1,A
   \   00005D   EF           MOV     A,R7
   \   00005E   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000061   8882         MOV     DPL,R0
   \   000063   8983         MOV     DPH,R1
   \   000065   F0           MOVX    @DPTR,A
    339                    serialNumber[idx-2] = hexDigit[aExtendedAddress[cnt] / 16];
   \   000066   EF           MOV     A,R7
   \   000067   C4           SWAP    A
   \   000068   12....       LCALL   ?Subroutine6 & 0xFFFF
    340                  }
   \                     ??CrossCallReturnLabel_1:
   \   00006B   C0E0         PUSH    A
   \   00006D   E8           MOV     A,R0
   \   00006E   24FE         ADD     A,#-0x2
   \   000070   F582         MOV     DPL,A
   \   000072   E9           MOV     A,R1
   \   000073   34FF         ADDC    A,#-0x1
   \   000075   F583         MOV     DPH,A
   \   000077   D0E0         POP     A
   \   000079   F0           MOVX    @DPTR,A
   \   00007A   0D           INC     R5
   \   00007B   74FC         MOV     A,#-0x4
   \   00007D   2C           ADD     A,R4
   \   00007E   FC           MOV     R4,A
   \   00007F   ED           MOV     A,R5
   \   000080   C3           CLR     C
   \   000081   9408         SUBB    A,#0x8
   \   000083   40BE         JC      ??usbdpGetStringDesc_6
    341                  serialNumber[0] = sizeof(serialNumber);
   \   000085   90....       MOV     DPTR,#??serialNumber
   \   000088   742A         MOV     A,#0x2a
   \   00008A   F0           MOVX    @DPTR,A
    342                }
    343                pStringDesc = (USB_STRING_DESCRIPTOR *)serialNumber;
   \                     ??usbdpGetStringDesc_5:
   \   00008B   7A..         MOV     R2,#??serialNumber & 0xff
   \   00008D   7B..         MOV     R3,#(??serialNumber >> 8) & 0xff
    344                break;
    345          
    346              default:
    347                break;
    348              }
    349            }
    350          
    351            return pStringDesc;
   \                     ??usbdpGetStringDesc_4:
   \   00008F   7408         MOV     A,#0x8
   \   000091   02....       LJMP    ?Subroutine5 & 0xFFFF
    352          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   540F         ANL     A,#0xf
   \   000002   FA           MOV     R2,A
   \   000003   74..         MOV     A,#hexDigit & 0xff
   \   000005   2A           ADD     A,R2
   \   000006   F582         MOV     DPL,A
   \   000008   E4           CLR     A
   \   000009   34..         ADDC    A,#(hexDigit >> 8) & 0xff
   \   00000B   F583         MOV     DPH,A
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   22           RET
    353          /// @}
    354          
    355          /*
    356          +------------------------------------------------------------------------------
    357          |  Copyright 2004-2011 Texas Instruments Incorporated. All rights reserved.
    358          |
    359          |  IMPORTANT: Your use of this Software is limited to those specific rights
    360          |  granted under the terms of a software license agreement between the user who
    361          |  downloaded the software, his/her employer (which must be your employer) and
    362          |  Texas Instruments Incorporated (the "License"). You may not use this Software
    363          |  unless you agree to abide by the terms of the License. The License limits
    364          |  your use, and you acknowledge, that the Software may not be modified, copied
    365          |  or distributed unless embedded on a Texas Instruments microcontroller or used
    366          |  solely and exclusively in conjunction with a Texas Instruments radio
    367          |  frequency transceiver, which is integrated into your product. Other than for
    368          |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
    369          |  works of, modify, distribute, perform, display or sell this Software and/or
    370          |  its documentation for any purpose.
    371          |
    372          |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
    373          |  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
    374          |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
    375          |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
    376          |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
    377          |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
    378          |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
    379          |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
    380          |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
    381          |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
    382          |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
    383          |
    384          |  Should you have any questions regarding your right to use this Software,
    385          |  contact Texas Instruments Incorporated at www.TI.com.
    386          |
    387          +------------------------------------------------------------------------------
    388          */
E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_framework.c
      1          /***********************************************************************************
      2          
      3              Filename:     usb_framework.c
      4          
      5              Description:  USB library common functionality.
      6          
      7          ***********************************************************************************/
      8          
      9          /// \addtogroup module_usb_framework
     10          /// @{
     11          #define USBFRAMEWORK_C ///< Modifies the behavior of "EXTERN" in usb_framework.h
     12          #include "usb_firmware_library_headers.h"

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \   USBFW_DATA usbfwData
   \                     usbfwData:
   \   000000                DS 20
   \   000014                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \   USB_SETUP_DATA usbSetupData
   \                     usbSetupData:
   \   000000                DS 5
   \   000005                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \   USB_SETUP_HEADER usbSetupHeader
   \                     usbSetupHeader:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
     13          #include "usb_board_cfg.h"
     14          
     15          // Function pointer used by usbfwSetupHandler()

   \                                 In  segment DATA_Z, align 1, keep-with-next
     16          static VFPTR __data ProcessFunc;
   \                     ??ProcessFunc:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_DATA_Z
     17          
     18          /** \brief Initializes the USB framework
     19           *
     20           * This function should be called when the microcontroller is ready to accept USB traffic. It enables the
     21           * USB peripheral unit and enables the pull-up resistor on the D+ line. Endpoint status, current
     22           * configuration value, etc. are initialized and evenetually re-initialized in the
     23           * \ref usbfwResetHandler() function.
     24           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     25          void usbfwInit(void)
   \                     usbfwInit:
     26          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     27              // Set default values
     28              usbfwData.selfPowered = (usbdpGetConfigurationDesc(1, 0)->bmAttributes & 0x40) ? TRUE : FALSE;
   \   000004                ; Setup parameters for call to function usbdpGetConfigurationDesc
   \   000004   7A00         MOV     R2,#0x0
   \   000006   7901         MOV     R1,#0x1
   \   000008   12....       LCALL   ??usbdpGetConfigurationDesc?relay; Banked call to: usbdpGetConfigurationDesc
   \   00000B   8A82         MOV     DPL,R2
   \   00000D   8B83         MOV     DPH,R3
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E4           CLR     A
   \   000017   93           MOVC    A,@A+DPTR
   \   000018   A2E6         MOV     C,0xE0 /* A   */.6
   \   00001A   90....       MOV     DPTR,#usbfwData + 19
   \   00001D   5004         JNC     ??usbfwInit_0
   \   00001F   7401         MOV     A,#0x1
   \   000021   8001         SJMP    ??usbfwInit_1
   \                     ??usbfwInit_0:
   \   000023   E4           CLR     A
   \                     ??usbfwInit_1:
   \   000024   F0           MOVX    @DPTR,A
     29              usbfwData.remoteWakeup = FALSE;
   \   000025   90....       MOV     DPTR,#usbfwData + 18
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
     30          
     31              HAL_USB_ENABLE();
   \   00002A   90620F       MOV     DPTR,#0x620f
   \   00002D   7403         MOV     A,#0x3
   \   00002F   F0           MOVX    @DPTR,A
   \                     ??usbfwInit_2:
   \   000030   E0           MOVX    A,@DPTR
   \   000031   A2E7         MOV     C,0xE0 /* A   */.7
   \   000033   50FB         JNC     ??usbfwInit_2
     32          
     33              // Enable Resume Interrupt
     34              HAL_USB_RESUME_INT_ENABLE();
     35          
     36          } // usbfwInit
   \   000035   02....       LJMP    ??Subroutine30_0 & 0xFFFF
     37          
     38          
     39          
     40          
     41          /** \brief Handles USB reset signalling
     42           *
     43           * This function should be called, either from the USB interrupt or the main loop, when the \c USBCIF.RST
     44           * flag has been set. Keep in mind that all bits in \c USBCIF register are cleared when the register is
     45           * read. The function puts the device into the default state (not yet addressed), and puts all endpoints
     46           * (except EP0) into the \ref EP_HALT state
     47           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     48          void usbfwResetHandler(void)
   \                     usbfwResetHandler:
     49          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     50          
     51             // Reset the USB state
     52             usbfwData.usbState = DEV_DEFAULT;
   \   000004   90....       MOV     DPTR,#usbfwData
   \   000007   7402         MOV     A,#0x2
   \   000009   F0           MOVX    @DPTR,A
     53             usbfwData.configurationValue = 0;
   \   00000A   A3           INC     DPTR
   \   00000B   E4           CLR     A
   \   00000C   F0           MOVX    @DPTR,A
     54          
     55             // Reset all endpoints
     56             usbfwData.ep0Status = EP_IDLE;
   \   00000D   90....       MOV     DPTR,#usbfwData + 7
   \   000010   F0           MOVX    @DPTR,A
     57             usbfwSetAllEpStatus(EP_HALT);
   \   000011                ; Setup parameters for call to function usbfwSetAllEpStatus
   \   000011   7903         MOV     R1,#0x3
   \   000013   12....       LCALL   ??usbfwSetAllEpStatus?relay; Banked call to: usbfwSetAllEpStatus
     58          
     59             // Reset last function pointer
     60             ProcessFunc = NULL;
   \   000016   75..00       MOV     ??ProcessFunc+0x0,#0x0
   \   000019   75..00       MOV     ??ProcessFunc+0x1,#0x0
     61          
     62          } // usbfwResetHandler
   \   00001C   02....       LJMP    ??Subroutine30_0 & 0xFFFF
     63          
     64          
     65          
     66          
     67          /** \brief USB Setup Handler
     68           *
     69           * This function should be called either from the USB interrupt or the main loop when the \c USBIIF.EP0IF
     70           * flag has been set. Keep in mind that all bits in \c USBIIF register are cleared when the register is
     71           * read. A detailed description of the framework is found in the \ref section_setup_handler_usage
     72           * section.
     73           *
     74           * \note The USB header data is always little-endian, so if a big-endian compiler is used (such as Keil
     75           * C51), the 16-bit values in the \ref usbSetupHeader must be flipped before they are used.
     76           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   90....       MOV     DPTR,#usbSetupData + 3
   \   000003                REQUIRE ??Subroutine28_0
   \   000003                ; // Fall through to label ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     77          void usbfwSetupHandler(void)
   \                     usbfwSetupHandler:
     78          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
     79             uint8 controlReg;
     80             uint8 bytesNow;
     81             uint8 oldEndpoint;
     82          
     83             // Save the old index setting, then select endpoint 0 and fetch the control register
     84             oldEndpoint = USBFW_GET_SELECTED_ENDPOINT();
   \   000005   90620E       MOV     DPTR,#0x620e
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FE           MOV     R6,A
     85             USBFW_SELECT_ENDPOINT(0);
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
     86             controlReg = USBCS0;
   \   00000C   906211       MOV     DPTR,#0x6211
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FF           MOV     R7,A
     87          
     88             // The last transfer was ended prematurely by a new SETUP packet
     89             if (controlReg & USBCS0_SETUP_END) {
   \   000011   A2E4         MOV     C,0xE0 /* A   */.4
   \   000013   501D         JNC     ??usbfwSetupHandler_0
     90                USBCS0 = USBCS0_CLR_SETUP_END;
   \   000015   7480         MOV     A,#-0x80
   \   000017   F0           MOVX    @DPTR,A
     91                usbfwData.ep0Status = EP_CANCEL;
   \   000018   90....       MOV     DPTR,#usbfwData + 7
   \   00001B   7407         MOV     A,#0x7
   \   00001D   F0           MOVX    @DPTR,A
     92                if (ProcessFunc) ProcessFunc();
   \   00001E   E5..         MOV     A,??ProcessFunc+0x0
   \   000020   45..         ORL     A,??ProcessFunc+0x1
   \   000022   6009         JZ      ??usbfwSetupHandler_1
   \   000024                ; Setup parameters for indirect call
   \   000024   85..82       MOV     DPL,??ProcessFunc+0x0
   \   000027   85..83       MOV     DPH,??ProcessFunc+0x1
   \   00002A   12....       LCALL   ?CALL_IND
     93                usbfwData.ep0Status = EP_IDLE;
   \                     ??usbfwSetupHandler_1:
   \   00002D   90....       MOV     DPTR,#usbfwData + 7
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
     94             }
     95          
     96             // A STALL handshake was transmitted to the PC
     97             if (controlReg & USBCS0_SENT_STALL) {
   \                     ??usbfwSetupHandler_0:
   \   000032   EF           MOV     A,R7
   \   000033   A2E2         MOV     C,0xE0 /* A   */.2
   \   000035   500B         JNC     ??usbfwSetupHandler_2
     98                USBCS0 = 0x00;
   \   000037   906211       MOV     DPTR,#0x6211
   \   00003A   E4           CLR     A
   \   00003B   F0           MOVX    @DPTR,A
     99                usbfwData.ep0Status = EP_IDLE;
   \   00003C   90....       MOV     DPTR,#usbfwData + 7
   \   00003F   F0           MOVX    @DPTR,A
   \   000040   8063         SJMP    ??usbfwSetupHandler_3
    100             }
    101          
    102             // Receive OUT packets
    103             if (usbfwData.ep0Status == EP_RX) {
   \                     ??usbfwSetupHandler_2:
   \   000042   90....       MOV     DPTR,#usbfwData + 7
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   7402         MOV     A,#0x2
   \   000049   68           XRL     A,R0
   \   00004A   7042         JNZ     ??usbfwSetupHandler_4
    104          
    105                // Read FIFO
    106                bytesNow = USBCNT0;
   \   00004C   906216       MOV     DPTR,#0x6216
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   FF           MOV     R7,A
    107                usbfwReadFifo(&USBF0, bytesNow, usbSetupData.pBuffer);
   \   000051                ; Setup parameters for call to function usbfwReadFifo
   \   000051   90....       MOV     DPTR,#usbSetupData
   \   000054   12....       LCALL   ?PUSH_XSTACK8_X_THREE
   \   000057   EF           MOV     A,R7
   \   000058   F9           MOV     R1,A
   \   000059   7A20         MOV     R2,#0x20
   \   00005B   7B62         MOV     R3,#0x62
   \   00005D   12....       LCALL   ??usbfwReadFifo?relay; Banked call to: usbfwReadFifo
   \   000060   7403         MOV     A,#0x3
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
    108                usbSetupData.bytesLeft -= bytesNow;
   \   000065   8F..         MOV     ?V0,R7
   \   000067   90....       MOV     DPTR,#usbSetupData + 3
   \   00006A   12....       LCALL   ?Subroutine18 & 0xFFFF
    109                usbSetupData.pBuffer += bytesNow;
   \                     ??CrossCallReturnLabel_20:
   \   00006D   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000070   E9           MOV     A,R1
   \   000071   2F           ADD     A,R7
   \   000072   12....       LCALL   ?Subroutine22 & 0xFFFF
    110          
    111                // Arm the endpoint
    112                USBCS0 = usbSetupData.bytesLeft ? USBCS0_CLR_OUTPKT_RDY : (USBCS0_CLR_OUTPKT_RDY | USBCS0_DATA_END);
   \                     ??CrossCallReturnLabel_28:
   \   000075   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000078   6004         JZ      ??usbfwSetupHandler_5
   \   00007A   7440         MOV     A,#0x40
   \   00007C   8002         SJMP    ??usbfwSetupHandler_6
   \                     ??usbfwSetupHandler_5:
   \   00007E   7448         MOV     A,#0x48
   \                     ??usbfwSetupHandler_6:
   \   000080   906211       MOV     DPTR,#0x6211
   \   000083   F0           MOVX    @DPTR,A
    113          
    114                // Make a call to the appropriate request handler when done
    115                if (usbSetupData.bytesLeft == 0) {
   \   000084   E8           MOV     A,R0
   \   000085   49           ORL     A,R1
   \   000086   6003         JZ      $+5
   \   000088   02....       LJMP    ??usbfwSetupHandler_7 & 0xFFFF
   \   00008B   02....       LJMP    ??usbfwSetupHandler_8 & 0xFFFF
    116                   if (ProcessFunc) ProcessFunc();
    117                   usbfwData.ep0Status = EP_IDLE;
    118                }
    119          
    120                // Return here since nothing more will happen until the next interrupt
    121                USBFW_SELECT_ENDPOINT(oldEndpoint);
    122                return;
    123          
    124             // Let the application handle the reception
    125             } else if (usbfwData.ep0Status == EP_MANUAL_RX) {
   \                     ??usbfwSetupHandler_4:
   \   00008E   7406         MOV     A,#0x6
   \   000090   68           XRL     A,R0
   \   000091   7009         JNZ     ??usbfwSetupHandler_9
    126                ProcessFunc();
   \   000093                ; Setup parameters for indirect call
   \   000093   85..82       MOV     DPL,??ProcessFunc+0x0
   \   000096   85..83       MOV     DPH,??ProcessFunc+0x1
   \   000099   12....       LCALL   ?CALL_IND
    127             }
    128          
    129             // Receive SETUP header
    130             if (usbfwData.ep0Status == EP_IDLE) {
   \                     ??usbfwSetupHandler_9:
   \   00009C   90....       MOV     DPTR,#usbfwData + 7
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   6003         JZ      $+5
   \   0000A2   02....       LJMP    ??usbfwSetupHandler_10 & 0xFFFF
    131                if (controlReg & USBCS0_OUTPKT_RDY) {
   \                     ??usbfwSetupHandler_3:
   \   0000A5   EF           MOV     A,R7
   \   0000A6   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000A8   4003         JC      $+5
   \   0000AA   02....       LJMP    ??usbfwSetupHandler_7 & 0xFFFF
    132                   usbfwReadFifo(&USBF0, 8, (uint8 __xdata *) &usbSetupHeader);
   \   0000AD                ; Setup parameters for call to function usbfwReadFifo
   \   0000AD   75....       MOV     ?V0,#usbSetupHeader & 0xff
   \   0000B0   75....       MOV     ?V1,#(usbSetupHeader >> 8) & 0xff
   \   0000B3   75..00       MOV     ?V2,#0x0
   \   0000B6   78..         MOV     R0,#?V0
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000BB   7908         MOV     R1,#0x8
   \   0000BD   7A20         MOV     R2,#0x20
   \   0000BF   7B62         MOV     R3,#0x62
   \   0000C1   12....       LCALL   ??usbfwReadFifo?relay; Banked call to: usbfwReadFifo
   \   0000C4   7403         MOV     A,#0x3
   \   0000C6   12....       LCALL   ?DEALLOC_XSTACK8
    133          
    134                   // Handle control transfers individually
    135                   ProcessFunc = NULL;
   \   0000C9   75..00       MOV     ??ProcessFunc+0x0,#0x0
   \   0000CC   75..00       MOV     ??ProcessFunc+0x1,#0x0
    136                   switch (usbSetupHeader.requestType & (RT_MASK_TYPE | RT_MASK_DIR)) {
   \   0000CF   90....       MOV     DPTR,#usbSetupHeader
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   54E0         ANL     A,#0xe0
   \   0000D5   601D         JZ      ??usbfwSetupHandler_11
   \   0000D7   24E0         ADD     A,#-0x20
   \   0000D9   7003         JNZ     $+5
   \   0000DB   02....       LJMP    ??usbfwSetupHandler_12 & 0xFFFF
   \   0000DE   24E0         ADD     A,#-0x20
   \   0000E0   6072         JZ      ??usbfwSetupHandler_13
   \   0000E2   24C0         ADD     A,#-0x40
   \   0000E4   6048         JZ      ??usbfwSetupHandler_14
   \   0000E6   24E0         ADD     A,#-0x20
   \   0000E8   7003         JNZ     $+5
   \   0000EA   02....       LJMP    ??usbfwSetupHandler_15 & 0xFFFF
   \   0000ED   24E0         ADD     A,#-0x20
   \   0000EF   606E         JZ      ??usbfwSetupHandler_16
   \   0000F1   02....       LJMP    ??usbfwSetupHandler_17 & 0xFFFF
    137          
    138                      // Standard requests with data from the host (OUT)
    139                   case RT_STD_OUT:
    140                      switch (usbSetupHeader.request) {
   \                     ??usbfwSetupHandler_11:
   \   0000F4   A3           INC     DPTR
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   14           DEC     A
   \   0000F7   6026         JZ      ??usbfwSetupHandler_18
   \   0000F9   24FE         ADD     A,#-0x2
   \   0000FB   601D         JZ      ??usbfwSetupHandler_19
   \   0000FD   24FE         ADD     A,#-0x2
   \   0000FF   600A         JZ      ??usbfwSetupHandler_20
   \   000101   24FC         ADD     A,#-0x4
   \   000103   601F         JZ      ??usbfwSetupHandler_21
   \   000105   24FE         ADD     A,#-0x2
   \   000107   6020         JZ      ??usbfwSetupHandler_22
   \   000109   8075         SJMP    ??usbfwSetupHandler_17
    141                      case SET_ADDRESS:       usbsrSetAddress(); break;
   \                     ??usbfwSetupHandler_20:
   \   00010B                ; Setup parameters for call to function usbsrSetAddress
   \   00010B   12....       LCALL   ??usbsrSetAddress?relay; Banked call to: usbsrSetAddress
    142                      case SET_FEATURE:       usbsrSetFeature(); break;
    143                      case CLEAR_FEATURE:     usbsrClearFeature(); break;
    144                      case SET_CONFIGURATION: usbsrSetConfiguration(); break;
    145                      case SET_INTERFACE:     usbsrSetInterface(); break;
    146                      case SET_DESCRIPTOR:    /*usbsrHookSetDescriptor(); break; - unsupported */
    147                      default:                usbfwData.ep0Status = EP_STALL; break;
    148                      }
    149                      break;
    150          
    151                      // Standard requests with data to the host (IN)
    152                   case RT_STD_IN:
    153                      switch (usbSetupHeader.request) {
    154                      case GET_STATUS:        usbsrGetStatus(); break;
    155                      case GET_DESCRIPTOR:    usbsrGetDescriptor(); break;
    156                      case GET_CONFIGURATION: usbsrGetConfiguration(); break;
    157                      case GET_INTERFACE:     usbsrGetInterface(); break;
    158                      case SYNCH_FRAME:       /*usbsrHookSynchFrame(); break; - unsupported */
    159                      default:                usbfwData.ep0Status = EP_STALL; break;
    160                      }
    161                      break;
    162          
    163                      // Vendor requests
    164                   case RT_VEND_OUT:
    165                      ProcessFunc = usbvrHookProcessOut; usbvrHookProcessOut();
    166                      break;
    167                   case RT_VEND_IN:
    168                      ProcessFunc = usbvrHookProcessIn; usbvrHookProcessIn();
    169                      break;
    170          
    171                      // Class requests
    172                   case RT_CLASS_OUT:
    173                      ProcessFunc = usbcrHookProcessOut; usbcrHookProcessOut();
    174                      break;
    175                   case RT_CLASS_IN:
    176                      ProcessFunc = usbcrHookProcessIn; usbcrHookProcessIn();
    177                      break;
    178          
    179                      // Unrecognized request: Stall the endpoint
    180                   default:
    181                      usbfwData.ep0Status = EP_STALL;
    182                      break;
    183                   }
    184          
    185                   // Arm/stall the endpoint
    186                   USBCS0 = (usbfwData.ep0Status == EP_STALL) ? (USBCS0_CLR_OUTPKT_RDY | USBCS0_SEND_STALL) : USBCS0_CLR_OUTPKT_RDY;
   \                     ??usbfwSetupHandler_23:
   \   00010E   90....       MOV     DPTR,#usbfwData + 7
   \   000111   E0           MOVX    A,@DPTR
   \   000112   6404         XRL     A,#0x4
   \   000114   7072         JNZ     ??usbfwSetupHandler_24
   \                     ??usbfwSetupHandler_25:
   \   000116   7460         MOV     A,#0x60
   \   000118   8070         SJMP    ??usbfwSetupHandler_26
   \                     ??usbfwSetupHandler_19:
   \   00011A                ; Setup parameters for call to function usbsrSetFeature
   \   00011A   12....       LCALL   ??usbsrSetFeature?relay; Banked call to: usbsrSetFeature
   \   00011D   80EF         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_18:
   \   00011F                ; Setup parameters for call to function usbsrClearFeature
   \   00011F   12....       LCALL   ??usbsrClearFeature?relay; Banked call to: usbsrClearFeature
   \   000122   80EA         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_21:
   \   000124                ; Setup parameters for call to function usbsrSetConfiguration
   \   000124   12....       LCALL   ??usbsrSetConfiguration?relay; Banked call to: usbsrSetConfiguration
   \   000127   80E5         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_22:
   \   000129                ; Setup parameters for call to function usbsrSetInterface
   \   000129   12....       LCALL   ??usbsrSetInterface?relay; Banked call to: usbsrSetInterface
   \   00012C   80E0         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_14:
   \   00012E   A3           INC     DPTR
   \   00012F   E0           MOVX    A,@DPTR
   \   000130   600E         JZ      ??usbfwSetupHandler_27
   \   000132   24FA         ADD     A,#-0x6
   \   000134   600F         JZ      ??usbfwSetupHandler_28
   \   000136   24FE         ADD     A,#-0x2
   \   000138   6010         JZ      ??usbfwSetupHandler_29
   \   00013A   24FE         ADD     A,#-0x2
   \   00013C   6011         JZ      ??usbfwSetupHandler_30
   \   00013E   8040         SJMP    ??usbfwSetupHandler_17
   \                     ??usbfwSetupHandler_27:
   \   000140                ; Setup parameters for call to function usbsrGetStatus
   \   000140   12....       LCALL   ??usbsrGetStatus?relay; Banked call to: usbsrGetStatus
   \   000143   80C9         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_28:
   \   000145                ; Setup parameters for call to function usbsrGetDescriptor
   \   000145   12....       LCALL   ??usbsrGetDescriptor?relay; Banked call to: usbsrGetDescriptor
   \   000148   80C4         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_29:
   \   00014A                ; Setup parameters for call to function usbsrGetConfiguration
   \   00014A   12....       LCALL   ??usbsrGetConfiguration?relay; Banked call to: usbsrGetConfiguration
   \   00014D   80BF         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_30:
   \   00014F                ; Setup parameters for call to function usbsrGetInterface
   \   00014F   12....       LCALL   ??usbsrGetInterface?relay; Banked call to: usbsrGetInterface
   \   000152   80BA         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_13:
   \   000154   75....       MOV     ??ProcessFunc+0x0,#??usbvrHookProcessOut?relay & 0xff
   \   000157   75....       MOV     ??ProcessFunc+0x1,#(??usbvrHookProcessOut?relay >> 8) & 0xff
   \   00015A                ; Setup parameters for call to function usbvrHookProcessOut
   \   00015A   12....       LCALL   ??usbvrHookProcessOut?relay; Banked call to: usbvrHookProcessOut
   \   00015D   80AF         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_16:
   \   00015F   75....       MOV     ??ProcessFunc+0x0,#??usbvrHookProcessIn?relay & 0xff
   \   000162   75....       MOV     ??ProcessFunc+0x1,#(??usbvrHookProcessIn?relay >> 8) & 0xff
   \   000165                ; Setup parameters for call to function usbvrHookProcessIn
   \   000165   12....       LCALL   ??usbvrHookProcessIn?relay; Banked call to: usbvrHookProcessIn
   \   000168   80A4         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_12:
   \   00016A   75....       MOV     ??ProcessFunc+0x0,#??usbcrHookProcessOut?relay & 0xff
   \   00016D   75....       MOV     ??ProcessFunc+0x1,#(??usbcrHookProcessOut?relay >> 8) & 0xff
   \   000170                ; Setup parameters for call to function usbcrHookProcessOut
   \   000170   12....       LCALL   ??usbcrHookProcessOut?relay; Banked call to: usbcrHookProcessOut
   \   000173   8099         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_15:
   \   000175   75....       MOV     ??ProcessFunc+0x0,#??usbcrHookProcessIn?relay & 0xff
   \   000178   75....       MOV     ??ProcessFunc+0x1,#(??usbcrHookProcessIn?relay >> 8) & 0xff
   \   00017B                ; Setup parameters for call to function usbcrHookProcessIn
   \   00017B   12....       LCALL   ??usbcrHookProcessIn?relay; Banked call to: usbcrHookProcessIn
   \   00017E   808E         SJMP    ??usbfwSetupHandler_23
   \                     ??usbfwSetupHandler_17:
   \   000180   90....       MOV     DPTR,#usbfwData + 7
   \   000183   7404         MOV     A,#0x4
   \   000185   F0           MOVX    @DPTR,A
   \   000186   808E         SJMP    ??usbfwSetupHandler_25
    187                }
    188             }
   \                     ??usbfwSetupHandler_24:
   \   000188   7440         MOV     A,#0x40
   \                     ??usbfwSetupHandler_26:
   \   00018A   906211       MOV     DPTR,#0x6211
   \   00018D   F0           MOVX    @DPTR,A
    189          
    190             // Transmit IN packets
    191             if (usbfwData.ep0Status == EP_TX) {
   \                     ??usbfwSetupHandler_10:
   \   00018E   90....       MOV     DPTR,#usbfwData + 7
   \   000191   E0           MOVX    A,@DPTR
   \   000192   F8           MOV     R0,A
   \   000193   7401         MOV     A,#0x1
   \   000195   68           XRL     A,R0
   \   000196   705D         JNZ     ??usbfwSetupHandler_31
    192                controlReg = USBCS0_INPKT_RDY;
   \   000198   7F02         MOV     R7,#0x2
    193          
    194                // The last frame should contain 0 to (EP0_PACKET_SIZE - 1) bytes
    195                if (usbSetupData.bytesLeft < EP0_PACKET_SIZE) {
   \   00019A   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00019D   C3           CLR     C
   \   00019E   E8           MOV     A,R0
   \   00019F   9420         SUBB    A,#0x20
   \   0001A1   E9           MOV     A,R1
   \   0001A2   9400         SUBB    A,#0x0
   \   0001A4   5007         JNC     ??usbfwSetupHandler_32
    196                   bytesNow = usbSetupData.bytesLeft;
   \   0001A6   E8           MOV     A,R0
   \   0001A7   F5..         MOV     ?V2,A
    197                   controlReg |= USBCS0_DATA_END;
   \   0001A9   7F0A         MOV     R7,#0xa
   \   0001AB   8003         SJMP    ??usbfwSetupHandler_33
    198          
    199                   // All other packets should have the maximum length
    200                } else {
    201                   bytesNow = EP0_PACKET_SIZE;
   \                     ??usbfwSetupHandler_32:
   \   0001AD   75..20       MOV     ?V2,#0x20
    202                }
    203          
    204                // Load the FIFO and move the pointer
    205                usbfwWriteFifo(&USBF0, bytesNow, usbSetupData.pBuffer);
   \                     ??usbfwSetupHandler_33:
   \   0001B0                ; Setup parameters for call to function usbfwWriteFifo
   \   0001B0   90....       MOV     DPTR,#usbSetupData
   \   0001B3   12....       LCALL   ?PUSH_XSTACK8_X_THREE
   \   0001B6   A9..         MOV     R1,?V2
   \   0001B8   7A20         MOV     R2,#0x20
   \   0001BA   7B62         MOV     R3,#0x62
   \   0001BC   12....       LCALL   ??usbfwWriteFifo?relay; Banked call to: usbfwWriteFifo
   \   0001BF   7403         MOV     A,#0x3
   \   0001C1   12....       LCALL   ?DEALLOC_XSTACK8
    206                usbSetupData.pBuffer += bytesNow;
   \   0001C4   85....       MOV     ?V0,?V2
   \   0001C7   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0001CA   E9           MOV     A,R1
   \   0001CB   25..         ADD     A,?V0
   \   0001CD   12....       LCALL   ?Subroutine22 & 0xFFFF
    207                usbSetupData.bytesLeft -= bytesNow;
   \                     ??CrossCallReturnLabel_29:
   \   0001D0   12....       LCALL   ?Subroutine18 & 0xFFFF
    208          
    209                // Arm the FIFO (even for a zero-length packet)
    210                USBCS0 = controlReg;
   \                     ??CrossCallReturnLabel_21:
   \   0001D3   EF           MOV     A,R7
   \   0001D4   906211       MOV     DPTR,#0x6211
   \   0001D7   F0           MOVX    @DPTR,A
    211          
    212                // Make a call to the appropriate request handler when done
    213                if (bytesNow < EP0_PACKET_SIZE) {
   \   0001D8   E5..         MOV     A,?V2
   \   0001DA   C3           CLR     C
   \   0001DB   9420         SUBB    A,#0x20
   \   0001DD   5024         JNC     ??usbfwSetupHandler_7
    214                   if (ProcessFunc) ProcessFunc();
   \                     ??usbfwSetupHandler_8:
   \   0001DF   E5..         MOV     A,??ProcessFunc+0x0
   \   0001E1   45..         ORL     A,??ProcessFunc+0x1
   \   0001E3   6009         JZ      ??usbfwSetupHandler_34
   \   0001E5                ; Setup parameters for indirect call
   \   0001E5   85..82       MOV     DPL,??ProcessFunc+0x0
   \   0001E8   85..83       MOV     DPH,??ProcessFunc+0x1
   \   0001EB   12....       LCALL   ?CALL_IND
    215                   usbfwData.ep0Status = EP_IDLE;
   \                     ??usbfwSetupHandler_34:
   \   0001EE   90....       MOV     DPTR,#usbfwData + 7
   \   0001F1   E4           CLR     A
   \   0001F2   F0           MOVX    @DPTR,A
   \   0001F3   800E         SJMP    ??usbfwSetupHandler_7
    216                }
    217          
    218             // Let the application handle the transmission
    219             } else if (usbfwData.ep0Status == EP_MANUAL_TX) {
   \                     ??usbfwSetupHandler_31:
   \   0001F5   7405         MOV     A,#0x5
   \   0001F7   68           XRL     A,R0
   \   0001F8   7009         JNZ     ??usbfwSetupHandler_7
    220                ProcessFunc();
   \   0001FA                ; Setup parameters for indirect call
   \   0001FA   85..82       MOV     DPL,??ProcessFunc+0x0
   \   0001FD   85..83       MOV     DPH,??ProcessFunc+0x1
   \   000200   12....       LCALL   ?CALL_IND
    221             }
    222          
    223             // Restore the old index setting
    224             USBFW_SELECT_ENDPOINT(oldEndpoint);
   \                     ??usbfwSetupHandler_7:
   \   000203   EE           MOV     A,R6
   \   000204   90620E       MOV     DPTR,#0x620e
   \   000207                REQUIRE ?Subroutine3
   \   000207                ; // Fall through to label ?Subroutine3
    225          
    226          } // usbfwSetupHandler

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   7F03         MOV     R7,#0x3
   \   000003   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F9           MOV     R1,A
   \   000001   E4           CLR     A
   \   000002   3A           ADDC    A,R2
   \   000003   FA           MOV     R2,A
   \   000004   90....       MOV     DPTR,#usbSetupData
   \   000007   E9           MOV     A,R1
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EA           MOV     A,R2
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   EB           MOV     A,R3
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   C3           CLR     C
   \   000001   E0           MOVX    A,@DPTR
   \   000002   95..         SUBB    A,?V0
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   9400         SUBB    A,#0x0
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   90....       MOV     DPTR,#usbSetupData
   \   000003                REQUIRE ??Subroutine31_0
   \   000003                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine32_0
   \   000003                ; // Fall through to label ??Subroutine32_0
    227          
    228          
    229          
    230          
    231          /** \brief Changes the state of endpoint 1-5 IN/OUT
    232           *
    233           * This is an internal function used by the library.
    234           *
    235           * \param[in]       status
    236           *     The new status for each endpoint
    237           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    238          void usbfwSetAllEpStatus(EP_STATUS status)
   \                     usbfwSetAllEpStatus:
    239          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    240             uint8 n;
    241             for (n = 0; n < sizeof(usbfwData.pEpInStatus); n++)
   \   000005   7800         MOV     R0,#0x0
    242                 usbfwData.pEpInStatus[n] = status;
   \                     ??usbfwSetAllEpStatus_0:
   \   000007   74..         MOV     A,#(usbfwData + 8) & 0xff
   \   000009   28           ADD     A,R0
   \   00000A   F582         MOV     DPL,A
   \   00000C   E4           CLR     A
   \   00000D   34..         ADDC    A,#((usbfwData + 8) >> 8) & 0xff
   \   00000F   F583         MOV     DPH,A
   \   000011   E9           MOV     A,R1
   \   000012   F0           MOVX    @DPTR,A
   \   000013   08           INC     R0
   \   000014   E8           MOV     A,R0
   \   000015   C3           CLR     C
   \   000016   9405         SUBB    A,#0x5
   \   000018   40ED         JC      ??usbfwSetAllEpStatus_0
    243             for (n = 0; n < sizeof(usbfwData.pEpOutStatus); n++)
   \   00001A   7800         MOV     R0,#0x0
    244                 usbfwData.pEpOutStatus[n] = status;
   \                     ??usbfwSetAllEpStatus_1:
   \   00001C   74..         MOV     A,#(usbfwData + 13) & 0xff
   \   00001E   28           ADD     A,R0
   \   00001F   F582         MOV     DPL,A
   \   000021   E4           CLR     A
   \   000022   34..         ADDC    A,#((usbfwData + 13) >> 8) & 0xff
   \   000024   F583         MOV     DPH,A
   \   000026   E9           MOV     A,R1
   \   000027   F0           MOVX    @DPTR,A
   \   000028   08           INC     R0
   \   000029   E8           MOV     A,R0
   \   00002A   C3           CLR     C
   \   00002B   9405         SUBB    A,#0x5
   \   00002D   40ED         JC      ??usbfwSetAllEpStatus_1
    245          } // usbfwSetAllEpStatus
   \   00002F   02....       LJMP    ??Subroutine27_0 & 0xFFFF
    246          
    247          
    248          
    249          
    250          /** \brief Reads from the selected OUT endpoint FIFO, without using DMA
    251           *
    252           * The FIFO must be re-armed after reading it empty (using the \ref USBFW_ARM_OUT_ENDPOINT() macro). This
    253           * is not necessary when flushing the FIFO.
    254           *
    255           * \param[in]       *pFifo
    256           *     Pointer to the FIFO (\c &USBFx)
    257           * \param[in]       count
    258           *     The number of bytes to read
    259           * \param[in]       *pData
    260           *     A pointer to the storage location for the read data (in any memory space)
    261           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    262          void usbfwReadFifo(uint8 volatile __xdata *pFifo, uint8 count, void __generic *pData)
   \                     usbfwReadFifo:
    263          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   \   000007   EB           MOV     A,R3
   \   000008   FD           MOV     R5,A
   \   000009   E9           MOV     A,R1
   \   00000A   F8           MOV     R0,A
    264             uint8 __generic *pTemp = pData;
   \   00000B   7409         MOV     A,#0x9
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   12....       LCALL   ??Subroutine31_0 & 0xFFFF
    265             if (count) {
   \                     ??CrossCallReturnLabel_45:
   \   000013   E8           MOV     A,R0
   \   000014   6011         JZ      ??usbfwReadFifo_0
    266                do {
    267                   *(pTemp++) = *pFifo;
   \                     ??usbfwReadFifo_1:
   \   000016   8C82         MOV     DPL,R4
   \   000018   8D83         MOV     DPH,R5
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   12....       LCALL   ?C_GPTR_STORE
   \   00001E   E9           MOV     A,R1
   \   00001F   2401         ADD     A,#0x1
   \   000021   09           INC     R1
   \   000022   E4           CLR     A
   \   000023   3A           ADDC    A,R2
   \   000024   FA           MOV     R2,A
    268                } while (--count);
   \   000025   D8EF         DJNZ    R0,??usbfwReadFifo_1
    269             }
    270          } // usbfwReadFifo
   \                     ??usbfwReadFifo_0:
   \   000027                REQUIRE ?Subroutine4
   \   000027                ; // Fall through to label ?Subroutine4

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    271          
    272          
    273          
    274          
    275          /** \brief Writes to the selected IN endpoint FIFO, without using DMA
    276           *
    277           * Note that the FIFO must be armed in order to be transmitted (using the \ref USBFW_ARM_IN_ENDPOINT()
    278           * macro).
    279           *
    280           * \param[in]       *pFifo
    281           *     Pointer to the FIFO (\c &USBFx)
    282           * \param[in]       count
    283           *     The number of bytes to write
    284           * \param[in]       *pData
    285           *     A pointer to the data to be written (from any memory space)
    286           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    287          void usbfwWriteFifo(uint8 volatile __xdata *pFifo, uint8 count, void __generic *pData)
   \                     usbfwWriteFifo:
    288          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   \   000007   EB           MOV     A,R3
   \   000008   FD           MOV     R5,A
   \   000009   E9           MOV     A,R1
   \   00000A   F8           MOV     R0,A
    289             uint8 __generic *pTemp = pData;
   \   00000B   7409         MOV     A,#0x9
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   12....       LCALL   ??Subroutine31_0 & 0xFFFF
    290             if (count) {
   \                     ??CrossCallReturnLabel_46:
   \   000013   E8           MOV     A,R0
   \   000014   6011         JZ      ??usbfwWriteFifo_0
    291                do {
    292                   *pFifo = *(pTemp++);
   \                     ??usbfwWriteFifo_1:
   \   000016   12....       LCALL   ?C_GPTR_LOAD
   \   000019   8C82         MOV     DPL,R4
   \   00001B   8D83         MOV     DPH,R5
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   E9           MOV     A,R1
   \   00001F   2401         ADD     A,#0x1
   \   000021   09           INC     R1
   \   000022   E4           CLR     A
   \   000023   3A           ADDC    A,R2
   \   000024   FA           MOV     R2,A
    293                } while (--count);
   \   000025   D8EF         DJNZ    R0,??usbfwWriteFifo_1
    294             }
    295          } // usbfwWriteFifo
   \                     ??usbfwWriteFifo_0:
   \   000027   80..         SJMP    ?Subroutine4
    296          
    297          
    298          /// @}
    299          /*
    300          +------------------------------------------------------------------------------
    301          |  Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
    302          |
    303          |  IMPORTANT: Your use of this Software is limited to those specific rights
    304          |  granted under the terms of a software license agreement between the user who
    305          |  downloaded the software, his/her employer (which must be your employer) and
    306          |  Texas Instruments Incorporated (the "License"). You may not use this Software
    307          |  unless you agree to abide by the terms of the License. The License limits
    308          |  your use, and you acknowledge, that the Software may not be modified, copied
    309          |  or distributed unless embedded on a Texas Instruments microcontroller or used
    310          |  solely and exclusively in conjunction with a Texas Instruments radio
    311          |  frequency transceiver, which is integrated into your product. Other than for
    312          |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
    313          |  works of, modify, distribute, perform, display or sell this Software and/or
    314          |  its documentation for any purpose.
    315          |
    316          |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
    317          |  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
    318          |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
    319          |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
    320          |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
    321          |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
    322          |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
    323          |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
    324          |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
    325          |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
    326          |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
    327          |
    328          |  Should you have any questions regarding your right to use this Software,
    329          |  contact Texas Instruments Incorporated at www.TI.com.
    330          |
    331          +------------------------------------------------------------------------------
    332          */
E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_interrupt.c
      1          /***********************************************************************************
      2          
      3              Filename:     usb_interrupt.c
      4          
      5              Description:  USB library interrupt initialisation and ISR.
      6          
      7          ***********************************************************************************/
      8          
      9          /// \addtogroup module_usb_interrupt
     10          /// @{
     11          #define USBINTERRUPT_C ///< Modifies the behavior of "EXTERN" in usb_interrupt.h
     12          #include "usb_firmware_library_headers.h"

   \                                 In  segment DATA_Z, align 1, keep-with-next
   \   USBIRQ_DATA __data usbirqData
   \                     usbirqData:
   \   000000                DS 5
   \   000005                REQUIRE __INIT_DATA_Z
     13          #include "usb_board_cfg.h"
     14          #include "hal_flash.h"
     15          
     16          /** \brief Initializes the \ref module_usb_interrupt module
     17           *
     18           * This function should be called after the \ref module_usb_framework module has been initialized.
     19           * Use interrupt group priority control (refer to the CC2531 datasheet) to adjust the priority of the
     20           * USB interrupt relative to other interrupts.
     21           *
     22           * \param[in]       irqMask
     23           *     A bit mask containing USBIRQ_EVENT bits for all events that shall be reported
     24           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   758B00       MOV     0x8b,#0x0
   \   000003   C2E8         CLR     0xe8.0
   \   000005                REQUIRE ??Subroutine27_0
   \   000005                ; // Fall through to label ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     25          void usbirqInit(uint16 irqMask)
   \                     usbirqInit:
     26          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
     27              // Initialize variables
     28              usbirqData.eventMask = 0x0000;
   \   000005   75..00       MOV     usbirqData+0x0,#0x0
   \   000008   75..00       MOV     usbirqData+0x1,#0x0
     29              usbirqData.inSuspend = FALSE;
   \   00000B   75..00       MOV     usbirqData + 2,#0x0
     30              usbirqData.irqMask = irqMask;
   \   00000E   8A..         MOV     usbirqData + 3+0x0,R2
   \   000010   8B..         MOV     usbirqData + 3+0x1,R3
     31          
     32              // Select which IRQ flags to handle
     33              USBCIE = irqMask;
   \   000012   EA           MOV     A,R2
   \   000013   90620B       MOV     DPTR,#0x620b
   \   000016   F0           MOVX    @DPTR,A
     34              USBIIE = irqMask >> 4;
   \   000017   8A..         MOV     ?V0,R2
   \   000019   8B..         MOV     ?V1,R3
   \   00001B   7404         MOV     A,#0x4
   \   00001D   78..         MOV     R0,#?V0
   \   00001F   12....       LCALL   ?US_SHR
   \   000022   E5..         MOV     A,?V0
   \   000024   906207       MOV     DPTR,#0x6207
   \   000027   F0           MOVX    @DPTR,A
     35              USBOIE = (irqMask >> 9) & 0x3E;
   \   000028   8A..         MOV     ?V0,R2
   \   00002A   8B..         MOV     ?V1,R3
   \   00002C   7409         MOV     A,#0x9
   \   00002E   78..         MOV     R0,#?V0
   \   000030   12....       LCALL   ?US_SHR
   \   000033   E5..         MOV     A,?V0
   \   000035   543E         ANL     A,#0x3e
   \   000037   906209       MOV     DPTR,#0x6209
   \   00003A   F0           MOVX    @DPTR,A
     36          
     37              HAL_USB_INT_CLEAR();
   \   00003B   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   00003E                REQUIRE P2IFG
   \   00003E                REQUIRE _A_IRCON2
     38              HAL_USB_INT_ENABLE();
     39          
     40          } // usbirqInit
     41          
     42          
     43          
     44          /** \brief USB interrupt handler
     45           *
     46           * Clears the P2 interrupt flag and converts all USB interrupt flags into events.
     47           * The interrupt also lets \ref usbsuspEnter() break from the suspend loop.
     48           */
     49          #if defined HAL_SB_BOOT_CODE

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     50          void usbirqHandler(void)
   \                     usbirqHandler:
     51          #else
     52          #pragma vector=P2INT_VECTOR
     53          __interrupt void usbirqHandler(void)
     54          #endif
     55          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
     56             uint8 usbcif;
     57          
     58             // First make sure that the crystal oscillator is stable
     59             while (!CC2530_IS_XOSC_STABLE());
   \                     ??usbirqHandler_0:
   \   000005   E59D         MOV     A,0x9d
   \   000007   A2E6         MOV     C,0xE0 /* A   */.6
   \   000009   50FA         JNC     ??usbirqHandler_0
     60          
     61             // Special handling for reset interrupts
     62             usbcif = USBCIF;
   \   00000B   906206       MOV     DPTR,#0x6206
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   FA           MOV     R2,A
     63             if (usbcif & USBCIF_RSTIF) {
   \   000010   A2E2         MOV     C,0xE0 /* A   */.2
   \   000012   5035         JNC     ??usbirqHandler_1
     64          
     65                 // All interrupts (except suspend) are by default enabled by hardware, so
     66                 // re-initialize the enable bits to avoid unwanted interrupts
     67                 USBCIE = usbirqData.irqMask;
   \   000014   A8..         MOV     R0,usbirqData + 3+0x0
   \   000016   E8           MOV     A,R0
   \   000017   90620B       MOV     DPTR,#0x620b
   \   00001A   F0           MOVX    @DPTR,A
     68                 USBIIE = usbirqData.irqMask >> 4;
   \   00001B   F5..         MOV     ?V0,A
   \   00001D   85....       MOV     ?V1,usbirqData + 3+0x1
   \   000020   7404         MOV     A,#0x4
   \   000022   78..         MOV     R0,#?V0
   \   000024   12....       LCALL   ?US_SHR
   \   000027   E5..         MOV     A,?V0
   \   000029   906207       MOV     DPTR,#0x6207
   \   00002C   F0           MOVX    @DPTR,A
     69                 USBOIE = (usbirqData.irqMask >> 9) & 0x3E;
   \   00002D   85....       MOV     ?V0,usbirqData + 3+0x0
   \   000030   85....       MOV     ?V1,usbirqData + 3+0x1
   \   000033   7409         MOV     A,#0x9
   \   000035   78..         MOV     R0,#?V0
   \   000037   12....       LCALL   ?US_SHR
   \   00003A   E5..         MOV     A,?V0
   \   00003C   543E         ANL     A,#0x3e
   \   00003E   906209       MOV     DPTR,#0x6209
   \   000041   F0           MOVX    @DPTR,A
     70          
     71                 // Enable suspend mode when suspend signaling is detected on the bus
     72                 USBPOW |= USBPOW_SUSPEND_EN;
   \   000042   906201       MOV     DPTR,#0x6201
   \   000045   E0           MOVX    A,@DPTR
   \   000046   D2E0         SETB    0xE0 /* A   */.0
   \   000048   F0           MOVX    @DPTR,A
     73             }
     74          
     75             // Record events (keeping existing)
     76             usbirqData.eventMask |= (uint16) usbcif;
   \                     ??usbirqHandler_1:
   \   000049   78..         MOV     R0,#usbirqData
   \   00004B   EA           MOV     A,R2
   \   00004C   46           ORL     A,@R0
   \   00004D   F6           MOV     @R0,A
     77             usbirqData.eventMask |= (uint16) USBIIF << 4;
   \   00004E   906202       MOV     DPTR,#0x6202
   \   000051   E0           MOVX    A,@DPTR
   \   000052   F5..         MOV     ?V0,A
   \   000054   75..00       MOV     ?V1,#0x0
   \   000057   7404         MOV     A,#0x4
   \   000059   78..         MOV     R0,#?V0
   \   00005B   12....       LCALL   ?S_SHL
   \   00005E   78..         MOV     R0,#usbirqData
   \   000060   E5..         MOV     A,?V0
   \   000062   46           ORL     A,@R0
   \   000063   F6           MOV     @R0,A
   \   000064   08           INC     R0
   \   000065   E5..         MOV     A,?V1
   \   000067   46           ORL     A,@R0
   \   000068   F6           MOV     @R0,A
     78             usbirqData.eventMask |= (uint16) USBOIF << 9;
   \   000069   906204       MOV     DPTR,#0x6204
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F5..         MOV     ?V0,A
   \   00006F   75..00       MOV     ?V1,#0x0
   \   000072   7409         MOV     A,#0x9
   \   000074   78..         MOV     R0,#?V0
   \   000076   12....       LCALL   ?S_SHL
   \   000079   78..         MOV     R0,#usbirqData + 1
   \   00007B   E5..         MOV     A,?V1
   \   00007D   46           ORL     A,@R0
   \   00007E   F6           MOV     @R0,A
     79          
     80             // If we get a suspend event, we should always enter suspend mode. We must,
     81             // however be sure that we exit the suspend loop upon resume or reset
     82             // signaling.
     83             if (usbcif & USBCIF_SUSPENDIF) {
   \   00007F   EA           MOV     A,R2
   \   000080   A2E0         MOV     C,0xE0 /* A   */.0
   \   000082   5003         JNC     ??usbirqHandler_2
     84                usbirqData.inSuspend = TRUE;
   \   000084   75..01       MOV     usbirqData + 2,#0x1
     85             }
     86             if (usbcif & (USBCIF_RSTIF | USBCIF_RESUMEIF)) {
   \                     ??usbirqHandler_2:
   \   000087   7406         MOV     A,#0x6
   \   000089   5A           ANL     A,R2
   \   00008A   6003         JZ      ??usbirqHandler_3
     87                usbirqData.inSuspend = FALSE;
   \   00008C   75..00       MOV     usbirqData + 2,#0x0
     88             }
     89             if (P2IFG & P2IFG_DPIF) {
   \                     ??usbirqHandler_3:
   \   00008F   E58B         MOV     A,0x8b
   \   000091   A2E5         MOV     C,0xE0 /* A   */.5
   \   000093   5006         JNC     ??usbirqHandler_4
     90                // Resume interrupt detected on D+ line while in suspend
     91                P2IFG = (P2IFG_DPIF ^ 0xFF);
   \   000095   758BDF       MOV     0x8b,#-0x21
     92                usbirqData.inSuspend = FALSE;
   \   000098   75..00       MOV     usbirqData + 2,#0x0
     93             }
     94          
     95             // Handle event which need immediate processing
     96             usbirqHookProcessEvents();
   \                     ??usbirqHandler_4:
   \   00009B                ; Setup parameters for call to function usbirqHookProcessEvents
   \   00009B   12....       LCALL   ??usbirqHookProcessEvents?relay; Banked call to: usbirqHookProcessEvents
     97          
     98             // Clear the interrupt
     99             HAL_USB_INT_CLEAR();
   \   00009E   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   0000A1                REQUIRE SLEEPSTA
   \   0000A1                REQUIRE P2IFG
   \   0000A1                REQUIRE _A_IRCON2
    100          
    101          } // usbirqHandler
    102          
    103          //@}
    104          
    105          /*
    106          +------------------------------------------------------------------------------
    107          |  Copyright 2008-2012 Texas Instruments Incorporated. All rights reserved.
    108          |
    109          |  IMPORTANT: Your use of this Software is limited to those specific rights
    110          |  granted under the terms of a software license agreement between the user who
    111          |  downloaded the software, his/her employer (which must be your employer) and
    112          |  Texas Instruments Incorporated (the "License"). You may not use this Software
    113          |  unless you agree to abide by the terms of the License. The License limits
    114          |  your use, and you acknowledge, that the Software may not be modified, copied
    115          |  or distributed unless embedded on a Texas Instruments microcontroller or used
    116          |  solely and exclusively in conjunction with a Texas Instruments radio
    117          |  frequency transceiver, which is integrated into your product. Other than for
    118          |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
    119          |  works of, modify, distribute, perform, display or sell this Software and/or
    120          |  its documentation for any purpose.
    121          |
    122          |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
    123          |  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
    124          |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
    125          |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
    126          |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
    127          |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
    128          |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
    129          |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
    130          |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
    131          |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
    132          |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
    133          |
    134          |  Should you have any questions regarding your right to use this Software,
    135          |  contact Texas Instruments Incorporated at www.TI.com.
    136          |
    137          +------------------------------------------------------------------------------
    138          */
E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_standard_requests.c
      1          /***********************************************************************************
      2          
      3              Filename:     usb_standard_request.c
      4          
      5              Description:  Handle USB standard requests.
      6          
      7          ***********************************************************************************/
      8          
      9          /// \addtogroup module_usb_standard_requests
     10          /// @{
     11          #include "usb_firmware_library_headers.h"
     12          #include "hal_types.h"
     13          #include "hal_board.h"
     14          
     15          
     16          
     17          /** \brief Processes the \ref GET_STATUS request (returns status for the specified recipient)
     18           *
     19           * The recipient bits in \ref USB_SETUP_HEADER.requestType specify the desired recipient. This is either the
     20           * (one and only) device, a specific interface, or a specific endpoint. Some of the status bits can be
     21           * changed with the SET_FEATURE and CLEAR_FEATURE requests.
     22           *
     23           * <b>Parameters</b>:
     24           * - VALUE: Always 0
     25           * - INDEX: Depends upon the recipient:
     26           *     - DEVICE: Always 0
     27           *     - INTERFACE: Interface number
     28           *     - ENDPOINT: Endpoint address
     29           * - LENGTH: Always 2
     30           *
     31           * <b>Data (IN)</b>:
     32           * Depends upon the recipient (the bit field illustrations are MSB first, LSB last):
     33           * - DEVICE: <tt>00000000.000000RS</tt>, where R(1) = DEVICE_REMOTE_WAKEUP and S(0) = SELF_POWERED
     34           * - INTERFACE: <tt>00000000.00000000</tt> (all bits are reserved)
     35           * - ENDPOINT: <tt>00000000.0000000H</tt>, where H(0) = ENDPOINT_HALT
     36           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     37          void usbsrGetStatus(void)
   \                     usbsrGetStatus:
     38          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
     39             uint8 endpoint;
     40             static uint16 __xdata status;
     41          
     42             // Common sanity check
     43             if (usbSetupHeader.value || HI_UINT16(usbSetupHeader.index) || (usbSetupHeader.length != 2)) {
   \   000005   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000008   6003         JZ      $+5
   \   00000A   02....       LJMP    ??usbsrGetStatus_0 & 0xFFFF
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   6003         JZ      $+5
   \   000014   02....       LJMP    ??usbsrGetStatus_0 & 0xFFFF
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   6402         XRL     A,#0x2
   \   00001B   7002         JNZ     ??usbsrGetStatus_1
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \                     ??usbsrGetStatus_1:
   \   00001F   6003         JZ      $+5
   \   000021   02....       LJMP    ??usbsrGetStatus_0 & 0xFFFF
     44                usbfwData.ep0Status = EP_STALL;
     45          
     46             // Return status for device, interface, or endpoint
     47             } else {
     48                switch (usbSetupHeader.requestType) {
   \   000024   90....       MOV     DPTR,#usbSetupHeader
   \   000027   E0           MOVX    A,@DPTR
   \   000028   2480         ADD     A,#-0x80
   \   00002A   6009         JZ      ??usbsrGetStatus_2
   \   00002C   14           DEC     A
   \   00002D   604F         JZ      ??usbsrGetStatus_3
   \   00002F   14           DEC     A
   \   000030   605C         JZ      ??usbsrGetStatus_4
   \   000032   02....       LJMP    ??usbsrGetStatus_0 & 0xFFFF
     49          
     50                   // Device status:
     51                   //     Bit 0: Self powered
     52                   //     Bit 1: Remote wake-up allowed
     53                case RT_IN_DEVICE:
     54          
     55                   // Sanity check
     56                   if (LO_UINT16(usbSetupHeader.index)) {
   \                     ??usbsrGetStatus_2:
   \   000035   E8           MOV     A,R0
   \   000036   6003         JZ      $+5
   \   000038   02....       LJMP    ??usbsrGetStatus_0 & 0xFFFF
     57                      usbfwData.ep0Status = EP_STALL;
     58          
     59                   // Get the bit values from the USBFW_DATA struct
     60                   } else {
     61          
     62                      // Self powered?
     63                      status = usbfwData.selfPowered ? 0x0001 : 0x0000;
   \   00003B   90....       MOV     DPTR,#usbfwData + 19
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   6004         JZ      ??usbsrGetStatus_5
   \   000041   7801         MOV     R0,#0x1
   \   000043   8002         SJMP    ??usbsrGetStatus_6
   \                     ??usbsrGetStatus_5:
   \   000045   7800         MOV     R0,#0x0
   \                     ??usbsrGetStatus_6:
   \   000047   90....       MOV     DPTR,#??status
   \   00004A   E8           MOV     A,R0
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   E4           CLR     A
   \   00004E   F0           MOVX    @DPTR,A
     64          
     65                      // Remote wakeup?
     66                      if (usbfwData.remoteWakeup) status |= 0x0002;
   \   00004F   90....       MOV     DPTR,#usbfwData + 18
   \   000052   E0           MOVX    A,@DPTR
   \   000053   600A         JZ      ??usbsrGetStatus_7
   \   000055   90....       MOV     DPTR,#??status
   \   000058   E0           MOVX    A,@DPTR
   \   000059   4402         ORL     A,#0x2
   \                     ??usbsrGetStatus_8:
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   E4           CLR     A
   \                     ??usbsrGetStatus_9:
   \   00005E   F0           MOVX    @DPTR,A
     67                   }
     68                   break;
     69          
     70                   // Interface status:
     71                   //     All bits are reserved
     72                case RT_IN_INTERFACE:
     73          
     74                   // Sanity check
     75                   if (usbfwData.usbState != DEV_CONFIGURED) {
     76                      usbfwData.ep0Status = EP_STALL;
     77                   } else {
     78                      status = 0x0000;
     79                   }
     80                   break;
     81          
     82                   // Endpoint status:
     83                   //     Bit 0: Endpoint halted
     84                case RT_IN_ENDPOINT:
     85                   endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
     86          
     87                   // Sanity check
     88                   if ((usbfwData.usbState != DEV_CONFIGURED) || (endpoint > 5)) {
     89                      usbfwData.ep0Status = EP_STALL;
     90          
     91                   // Translate endpoint address to status index and return the status
     92                   } else {
     93          
     94                      // IN
     95                      if (LO_UINT16(usbSetupHeader.index) & 0x80) {
     96                         status = (usbfwData.pEpInStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
     97          
     98                      // OUT
     99                      } else {
    100                         status = (usbfwData.pEpOutStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
    101                      }
    102                   }
    103                   break;
    104          
    105                default:
    106                   usbfwData.ep0Status = EP_STALL;
    107                   break;
    108                }
    109          
    110                if (usbfwData.ep0Status != EP_STALL) {
   \                     ??usbsrGetStatus_7:
   \   00005F   90....       MOV     DPTR,#usbfwData + 7
   \   000062   E0           MOVX    A,@DPTR
   \   000063   6404         XRL     A,#0x4
   \   000065   6014         JZ      ??usbsrGetStatus_10
    111                   // Send it
    112                   usbSetupData.pBuffer = (uint8 __generic *)&status;
   \   000067   90....       MOV     DPTR,#usbSetupData
   \   00006A   74..         MOV     A,#??status & 0xff
   \   00006C   F0           MOVX    @DPTR,A
   \   00006D   A3           INC     DPTR
   \   00006E   74..         MOV     A,#(??status >> 8) & 0xff
   \   000070   F0           MOVX    @DPTR,A
   \   000071   A3           INC     DPTR
   \   000072   E4           CLR     A
   \   000073   F0           MOVX    @DPTR,A
    113                   usbSetupData.bytesLeft = 2;
   \   000074   A3           INC     DPTR
   \   000075   7402         MOV     A,#0x2
   \   000077   12....       LCALL   ?Subroutine26 & 0xFFFF
    114                   usbfwData.ep0Status = EP_TX;
    115                }
   \                     ??CrossCallReturnLabel_34:
   \   00007A   F0           MOVX    @DPTR,A
    116             }
    117          } // usbsrGetStatus
   \                     ??usbsrGetStatus_10:
   \   00007B   02....       LJMP    ??Subroutine27_0 & 0xFFFF
   \                     ??usbsrGetStatus_3:
   \   00007E   90....       MOV     DPTR,#usbfwData
   \   000081   E0           MOVX    A,@DPTR
   \   000082   6404         XRL     A,#0x4
   \   000084   7055         JNZ     ??usbsrGetStatus_0
   \   000086   90....       MOV     DPTR,#??status
   \   000089   E4           CLR     A
   \   00008A   F0           MOVX    @DPTR,A
   \   00008B   A3           INC     DPTR
   \   00008C   80D0         SJMP    ??usbsrGetStatus_9
   \                     ??usbsrGetStatus_4:
   \   00008E   E8           MOV     A,R0
   \   00008F   547F         ANL     A,#0x7f
   \   000091   F5..         MOV     ?V0,A
   \   000093   90....       MOV     DPTR,#usbfwData
   \   000096   E0           MOVX    A,@DPTR
   \   000097   6404         XRL     A,#0x4
   \   000099   7040         JNZ     ??usbsrGetStatus_0
   \   00009B   E5..         MOV     A,?V0
   \   00009D   C3           CLR     C
   \   00009E   9406         SUBB    A,#0x6
   \   0000A0   5039         JNC     ??usbsrGetStatus_0
   \   0000A2   74..         MOV     A,#usbfwData & 0xff
   \   0000A4   25..         ADD     A,?V0
   \   0000A6   F582         MOV     DPL,A
   \   0000A8   E4           CLR     A
   \   0000A9   34..         ADDC    A,#(usbfwData >> 8) & 0xff
   \   0000AB   F583         MOV     DPH,A
   \   0000AD   E8           MOV     A,R0
   \   0000AE   5480         ANL     A,#0x80
   \   0000B0   6018         JZ      ??usbsrGetStatus_11
   \   0000B2   A3           INC     DPTR
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   6403         XRL     A,#0x3
   \   0000BC   7004         JNZ     ??usbsrGetStatus_12
   \                     ??usbsrGetStatus_13:
   \   0000BE   7801         MOV     R0,#0x1
   \   0000C0   8002         SJMP    ??usbsrGetStatus_14
   \                     ??usbsrGetStatus_12:
   \   0000C2   7800         MOV     R0,#0x0
   \                     ??usbsrGetStatus_14:
   \   0000C4   90....       MOV     DPTR,#??status
   \   0000C7   E8           MOV     A,R0
   \   0000C8   8091         SJMP    ??usbsrGetStatus_8
   \                     ??usbsrGetStatus_11:
   \   0000CA   E582         MOV     A,DPL
   \   0000CC   240C         ADD     A,#0xc
   \   0000CE   F582         MOV     DPL,A
   \   0000D0   5002         JNC     ??usbsrGetStatus_15
   \   0000D2   0583         INC     DPH
   \                     ??usbsrGetStatus_15:
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   6403         XRL     A,#0x3
   \   0000D7   70E9         JNZ     ??usbsrGetStatus_12
   \   0000D9   80E3         SJMP    ??usbsrGetStatus_13
   \                     ??usbsrGetStatus_0:
   \   0000DB   90....       MOV     DPTR,#usbfwData + 7
   \   0000DE   7404         MOV     A,#0x4
   \   0000E0   8098         SJMP    ??CrossCallReturnLabel_34

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000003                REQUIRE ??Subroutine33_0
   \   000003                ; // Fall through to label ??Subroutine33_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E4           CLR     A
   \   000003   F0           MOVX    @DPTR,A
   \   000004   90....       MOV     DPTR,#usbfwData + 7
   \   000007   04           INC     A
   \   000008   22           RET

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??status:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    118          
    119          
    120          
    121          
    122          /** \brief Internal function used for the very similar \ref SET_FEATURE and \ref CLEAR_FEATURE requests
    123           *
    124           * This function either sets or clears the specified feature on the specified recipient.
    125           *
    126           * \param[in]       set
    127           *     When TRUE, the feature is set. When FALSE, the feature is cleared.
    128           *
    129           * \return
    130           *     TRUE if the selected feature is supported by the USB library. FALSE to indicate that
    131           *     \ref usbsrHookClearFeature() or \ref usbsrHookSetFeature() must be called.
    132           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    133          static uint8 ChangeFeature(uint8 set)
   \                     ??ChangeFeature:
    134          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    135             uint8 endpoint;
    136          
    137             // Sanity check
    138             if (usbSetupHeader.length || (usbfwData.usbState != DEV_CONFIGURED) && (usbSetupHeader.index != 0)) {
   \   000007   90....       MOV     DPTR,#usbSetupHeader + 6
   \   00000A   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00000D   6003         JZ      $+5
   \   00000F   02....       LJMP    ??ChangeFeature_1 & 0xFFFF
   \   000012   90....       MOV     DPTR,#usbfwData
   \   000015   E0           MOVX    A,@DPTR
   \   000016   6404         XRL     A,#0x4
   \   000018   600B         JZ      ??ChangeFeature_2
   \   00001A   90....       MOV     DPTR,#usbSetupHeader + 4
   \   00001D   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000020   6003         JZ      $+5
   \   000022   02....       LJMP    ??ChangeFeature_1 & 0xFFFF
    139                usbfwData.ep0Status = EP_STALL;
    140          
    141                // Handle based on recipient
    142             } else {
    143                switch (usbSetupHeader.requestType & RT_MASK_RECIP) {
   \                     ??ChangeFeature_2:
   \   000025   90....       MOV     DPTR,#usbSetupHeader
   \   000028   E0           MOVX    A,@DPTR
   \   000029   541F         ANL     A,#0x1f
   \   00002B   6009         JZ      ??ChangeFeature_3
   \   00002D   14           DEC     A
   \   00002E   6030         JZ      ??ChangeFeature_4
   \   000030   14           DEC     A
   \   000031   6020         JZ      ??ChangeFeature_5
   \   000033   02....       LJMP    ??ChangeFeature_1 & 0xFFFF
    144          
    145                // Device
    146                case RT_RECIP_DEV:
    147          
    148                   // Sanity check
    149                   if (LO_UINT16(usbSetupHeader.value) != DEVICE_REMOTE_WAKEUP) {
   \                     ??ChangeFeature_3:
   \   000036   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6401         XRL     A,#0x1
   \   00003C   7022         JNZ     ??ChangeFeature_4
    150                      return FALSE;
    151                   } else {
    152                      usbfwData.remoteWakeup = set;
   \   00003E   EE           MOV     A,R6
   \   00003F   90....       MOV     DPTR,#usbfwData + 18
   \   000042   F0           MOVX    @DPTR,A
    153                      usbsrHookProcessEvent(set ? USBSR_EVENT_REMOTE_WAKEUP_ENABLED : USBSR_EVENT_REMOTE_WAKEUP_DISABLED, 0);
   \   000043   6004         JZ      ??ChangeFeature_6
   \   000045   7905         MOV     R1,#0x5
   \   000047   8002         SJMP    ??ChangeFeature_7
   \                     ??ChangeFeature_6:
   \   000049   7906         MOV     R1,#0x6
   \                     ??ChangeFeature_7:
   \   00004B                ; Setup parameters for call to function usbsrHookProcessEvent
   \   00004B   7A00         MOV     R2,#0x0
   \   00004D   12....       LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
    154                   }
    155                   break;
   \   000050   02....       LJMP    ??ChangeFeature_8 & 0xFFFF
    156          
    157                // Endpoint
    158                case RT_RECIP_IF:
    159                   return FALSE;
    160          
    161                // Endpoint
    162                case RT_RECIP_EP:
    163                   endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
   \                     ??ChangeFeature_5:
   \   000053   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000056   E0           MOVX    A,@DPTR
   \   000057   547F         ANL     A,#0x7f
   \   000059   FA           MOV     R2,A
    164          
    165                   // Sanity check
    166                   if (LO_UINT16(usbSetupHeader.value) != ENDPOINT_HALT) {
   \   00005A   90....       MOV     DPTR,#usbSetupHeader + 2
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   6005         JZ      ??ChangeFeature_9
    167                      return FALSE;
   \                     ??ChangeFeature_4:
   \   000060   7900         MOV     R1,#0x0
   \   000062   02....       LJMP    ??ChangeFeature_10 & 0xFFFF
    168                   } else if (endpoint > 5) {
   \                     ??ChangeFeature_9:
   \   000065   EA           MOV     A,R2
   \   000066   C3           CLR     C
   \   000067   9406         SUBB    A,#0x6
   \   000069   5076         JNC     ??ChangeFeature_1
    169                      usbfwData.ep0Status = EP_STALL;
    170                   } else {
    171                      USBFW_SELECT_ENDPOINT(endpoint);
   \   00006B   EA           MOV     A,R2
   \   00006C   90620E       MOV     DPTR,#0x620e
   \   00006F   F0           MOVX    @DPTR,A
    172          
    173                      // IN
    174                      if (LO_UINT16(usbSetupHeader.index) & 0x80) {
   \   000070   74..         MOV     A,#usbfwData & 0xff
   \   000072   2A           ADD     A,R2
   \   000073   F8           MOV     R0,A
   \   000074   E4           CLR     A
   \   000075   34..         ADDC    A,#(usbfwData >> 8) & 0xff
   \   000077   F9           MOV     R1,A
   \   000078   90....       MOV     DPTR,#usbSetupHeader + 4
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   5480         ANL     A,#0x80
   \   00007E   602C         JZ      ??ChangeFeature_11
    175                         USBCSIL = set ? USBCSIL_SEND_STALL : USBCSIL_CLR_DATA_TOG;
   \   000080   EE           MOV     A,R6
   \   000081   6004         JZ      ??ChangeFeature_12
   \   000083   7410         MOV     A,#0x10
   \   000085   8002         SJMP    ??ChangeFeature_13
   \                     ??ChangeFeature_12:
   \   000087   7440         MOV     A,#0x40
   \                     ??ChangeFeature_13:
   \   000089   906211       MOV     DPTR,#0x6211
   \   00008C   F0           MOVX    @DPTR,A
    176                         usbfwData.pEpInStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
   \   00008D   EE           MOV     A,R6
   \   00008E   6004         JZ      ??ChangeFeature_14
   \   000090   7403         MOV     A,#0x3
   \   000092   8001         SJMP    ??ChangeFeature_15
   \                     ??ChangeFeature_14:
   \   000094   E4           CLR     A
   \                     ??ChangeFeature_15:
   \   000095   8882         MOV     DPL,R0
   \   000097   8983         MOV     DPH,R1
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   F0           MOVX    @DPTR,A
    177                         usbsrHookProcessEvent(set ? USBSR_EVENT_EPIN_STALL_SET : USBSR_EVENT_EPIN_STALL_CLEARED, endpoint);
   \   0000A1   EE           MOV     A,R6
   \   0000A2   6004         JZ      ??ChangeFeature_16
   \   0000A4   7908         MOV     R1,#0x8
   \   0000A6   8030         SJMP    ??ChangeFeature_17
   \                     ??ChangeFeature_16:
   \   0000A8   7907         MOV     R1,#0x7
   \   0000AA                ; Setup parameters for call to function usbsrHookProcessEvent
   \   0000AA   802C         SJMP    ??ChangeFeature_17
    178          
    179                      // OUT
    180                      } else {
    181                         USBCSOL = set ? USBCSOL_SEND_STALL : USBCSOL_CLR_DATA_TOG;
   \                     ??ChangeFeature_11:
   \   0000AC   EE           MOV     A,R6
   \   0000AD   6004         JZ      ??ChangeFeature_18
   \   0000AF   7420         MOV     A,#0x20
   \   0000B1   8002         SJMP    ??ChangeFeature_19
   \                     ??ChangeFeature_18:
   \   0000B3   7480         MOV     A,#-0x80
   \                     ??ChangeFeature_19:
   \   0000B5   906214       MOV     DPTR,#0x6214
   \   0000B8   F0           MOVX    @DPTR,A
    182                         usbfwData.pEpOutStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
   \   0000B9   EE           MOV     A,R6
   \   0000BA   6004         JZ      ??ChangeFeature_20
   \   0000BC   7403         MOV     A,#0x3
   \   0000BE   8001         SJMP    ??ChangeFeature_21
   \                     ??ChangeFeature_20:
   \   0000C0   E4           CLR     A
   \                     ??ChangeFeature_21:
   \   0000C1   C0E0         PUSH    A
   \   0000C3   E8           MOV     A,R0
   \   0000C4   240C         ADD     A,#0xc
   \   0000C6   F582         MOV     DPL,A
   \   0000C8   E4           CLR     A
   \   0000C9   39           ADDC    A,R1
   \   0000CA   F583         MOV     DPH,A
   \   0000CC   D0E0         POP     A
   \   0000CE   F0           MOVX    @DPTR,A
    183                         usbsrHookProcessEvent(set ? USBSR_EVENT_EPOUT_STALL_SET : USBSR_EVENT_EPOUT_STALL_CLEARED, endpoint);
   \   0000CF   EE           MOV     A,R6
   \   0000D0   6004         JZ      ??ChangeFeature_22
   \   0000D2   790A         MOV     R1,#0xa
   \   0000D4   8002         SJMP    ??ChangeFeature_17
   \                     ??ChangeFeature_22:
   \   0000D6   7909         MOV     R1,#0x9
   \                     ??ChangeFeature_17:
   \   0000D8                ; Setup parameters for call to function usbsrHookProcessEvent
   \   0000D8   12....       LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
    184                      }
    185                      USBFW_SELECT_ENDPOINT(0);
   \   0000DB   90620E       MOV     DPTR,#0x620e
   \   0000DE   E4           CLR     A
   \   0000DF   8005         SJMP    ??ChangeFeature_23
    186                   }
    187                   break;
    188          
    189                default:
    190                   usbfwData.ep0Status = EP_STALL;
   \                     ??ChangeFeature_1:
   \   0000E1   90....       MOV     DPTR,#usbfwData + 7
   \   0000E4   7404         MOV     A,#0x4
   \                     ??ChangeFeature_23:
   \   0000E6   F0           MOVX    @DPTR,A
    191                   break;
    192                }
    193             }
    194             return TRUE;
   \                     ??ChangeFeature_8:
   \   0000E7   7901         MOV     R1,#0x1
   \                     ??ChangeFeature_10:
   \   0000E9   02....       LJMP    ??Subroutine27_0 & 0xFFFF
    195          } // ChangeFeature
    196          
    197          
    198          
    199          
    200          /** \brief Processes the \ref CLEAR_FEATURE request (clears or disables a specific feature)
    201           *
    202           * The feature selector value must be appropriate to the recipient.
    203           *
    204           * <b>Parameters</b>:
    205           * - VALUE: Feature selector:
    206           *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
    207           *     - \c ENDPOINT_HALT(0): Clear the halt feature for the specified endpoint (not endpoint 0!)
    208           * - INDEX: Depends upon the recipient:
    209           *     - DEVICE: Always 0
    210           *     - INTERFACE: Interface number
    211           *     - ENDPOINT: Endpoint address
    212           * - LENGTH: Always 0
    213           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    214          void usbsrClearFeature()
   \                     usbsrClearFeature:
    215          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    216             if (!ChangeFeature(FALSE)) {
   \   000004                ; Setup parameters for call to function ChangeFeature
   \   000004   7900         MOV     R1,#0x0
   \   000006   12....       LCALL   ??ChangeFeature?relay; Banked call to: ChangeFeature
   \   000009   E9           MOV     A,R1
   \   00000A   7003         JNZ     ??usbsrClearFeature_0
    217                usbsrHookClearFeature();
   \   00000C                ; Setup parameters for call to function usbsrHookClearFeature
   \   00000C   12....       LCALL   ??usbsrHookClearFeature?relay; Banked call to: usbsrHookClearFeature
    218             }
    219          } // usbsrClearFeature
   \                     ??usbsrClearFeature_0:
   \   00000F   02....       LJMP    ??Subroutine30_0 & 0xFFFF
    220          
    221          
    222          
    223          
    224          /** \brief Processes the \ref SET_FEATURE request (sets or enables a specific feature)
    225           *
    226           * The feature selector value must be appropriate to the recipient.
    227           *
    228           * <b>Parameters</b>:
    229           * - VALUE: Feature selector:
    230           *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
    231           *     - \c ENDPOINT_HALT(0): Set the halt feature for the specified endpoint (not endpoint 0!)
    232           * - INDEX: Depends upon the recipient:
    233           *     - DEVICE: Always 0
    234           *     - INTERFACE: Interface number
    235           *     - ENDPOINT: Endpoint address
    236           * - LENGTH: Always 0
    237           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    238          void usbsrSetFeature(void)
   \                     usbsrSetFeature:
    239          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    240             if (!ChangeFeature(TRUE)) {
   \   000004                ; Setup parameters for call to function ChangeFeature
   \   000004   7901         MOV     R1,#0x1
   \   000006   12....       LCALL   ??ChangeFeature?relay; Banked call to: ChangeFeature
   \   000009   E9           MOV     A,R1
   \   00000A   7003         JNZ     ??usbsrSetFeature_0
    241                usbsrHookSetFeature();
   \   00000C                ; Setup parameters for call to function usbsrHookSetFeature
   \   00000C   12....       LCALL   ??usbsrHookSetFeature?relay; Banked call to: usbsrHookSetFeature
    242             }
    243          } // usbsrSetFeature
   \                     ??usbsrSetFeature_0:
   \   00000F   02....       LJMP    ??Subroutine30_0 & 0xFFFF
    244          
    245          
    246          
    247          
    248          /** \brief Processes the \ref SET_ADDRESS request (sets the device address for all future device
    249           * accesses)
    250           *
    251           * If the value is between 1 and 127 and the device is in the default state, it will enter the address
    252           * state. If it already is in the address state, it starts to use the newly-specified address.
    253           *
    254           * If the value is 0 and the device is in the address state, it will enter the default state. If it
    255           * already is in the default state, nothing happens.
    256           *
    257           * <b>Parameters</b>:
    258           * - VALUE: The device address (0-127)
    259           * - INDEX: Always 0
    260           * - LENGTH: Always 0
    261           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    262          void usbsrSetAddress(void)
   \                     usbsrSetAddress:
    263          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    264          
    265             // Sanity check
    266             if (usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value) || (LO_UINT16(usbSetupHeader.value) & 0x80)) {
   \   000004   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000007   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00000A   7015         JNZ     ??usbsrSetAddress_0
   \   00000C   A3           INC     DPTR
   \   00000D   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000010   700F         JNZ     ??usbsrSetAddress_0
   \   000012   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000015   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000018   5480         ANL     A,#0x80
   \   00001A   FA           MOV     R2,A
   \   00001B   E9           MOV     A,R1
   \   00001C   FB           MOV     R3,A
   \   00001D   EA           MOV     A,R2
   \   00001E   4B           ORL     A,R3
   \   00001F   6007         JZ      ??usbsrSetAddress_1
    267                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetAddress_0:
   \   000021   90....       MOV     DPTR,#usbfwData + 7
   \   000024   7404         MOV     A,#0x4
   \   000026   801A         SJMP    ??usbsrSetAddress_2
    268          
    269             // Update the device address
    270             } else {
    271                USBADDR = LO_UINT16(usbSetupHeader.value);
   \                     ??usbsrSetAddress_1:
   \   000028   E8           MOV     A,R0
   \   000029   906200       MOV     DPTR,#0x6200
   \   00002C   F0           MOVX    @DPTR,A
    272                if (LO_UINT16(usbSetupHeader.value) != 0) {
   \   00002D   90....       MOV     DPTR,#usbfwData
   \   000030   6009         JZ      ??usbsrSetAddress_3
    273                   if (usbfwData.usbState == DEV_DEFAULT) usbfwData.usbState = DEV_ADDRESS;
   \   000032   E0           MOVX    A,@DPTR
   \   000033   6402         XRL     A,#0x2
   \   000035   700C         JNZ     ??usbsrSetAddress_4
   \   000037   7403         MOV     A,#0x3
   \   000039   8007         SJMP    ??usbsrSetAddress_2
    274                } else {
    275                   if (usbfwData.usbState == DEV_ADDRESS) usbfwData.usbState = DEV_DEFAULT;
   \                     ??usbsrSetAddress_3:
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   6403         XRL     A,#0x3
   \   00003E   7003         JNZ     ??usbsrSetAddress_4
   \   000040   7402         MOV     A,#0x2
   \                     ??usbsrSetAddress_2:
   \   000042   F0           MOVX    @DPTR,A
    276                }
    277             }
    278          
    279          } // usbsrSetAddress
   \                     ??usbsrSetAddress_4:
   \   000043   02....       LJMP    ??Subroutine30_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET
    280          
    281          
    282          
    283          
    284          /** \brief Processes the \ref GET_DESCRIPTOR request (returns the specified USB descriptor)
    285           *
    286           * The \ref module_usb_descriptor_parser module is used to locate device, configuration and string
    287           * descriptors. Note that configuration descriptors also include interface, endpoint and other
    288           * "similar" descriptor types (e.g. HID descriptor), with the total descriptor length specified by
    289           * the \ref USB_CONFIGURATION_DESCRIPTOR.wTotalLength field.
    290           *
    291           * Other descriptor types that are not returned with the configuration descriptor, must be defined in
    292           * the usbDescriptorMarker.pUsbDescLut lookup-table. This table specifies the values of the VALUE and INDEX fields, and
    293           * gives a pointer to the descriptor along with it's length.
    294           *
    295           * <b>Parameters</b>:
    296           * - VALUE.MSB: Descriptor type
    297           * - VALUE.LSB: Descriptor index
    298           * - INDEX: 0, or language ID for string descriptors (currently not supported)
    299           * - LENGTH: Descriptor length (either the requested number of bytes, or the length of the descriptor,
    300           *           whichever is the smallest)
    301           *
    302           * <b>Data (IN)</b>:
    303           * The descriptor(s)
    304           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    305          void usbsrGetDescriptor(void)
   \                     usbsrGetDescriptor:
    306          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
    307             uint8 n;
    308          
    309             // Which descriptor?
    310             switch (HI_UINT16(usbSetupHeader.value)) {
   \   000005   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FA           MOV     R2,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   14           DEC     A
   \   00000D   6008         JZ      ??usbsrGetDescriptor_0
   \   00000F   14           DEC     A
   \   000010   6010         JZ      ??usbsrGetDescriptor_1
   \   000012   14           DEC     A
   \   000013   6039         JZ      ??usbsrGetDescriptor_2
   \   000015   8057         SJMP    ??usbsrGetDescriptor_3
    311          
    312             // Device descriptor
    313             case DESC_TYPE_DEVICE:
    314                usbSetupData.pBuffer = (uint8 __code*) usbdpGetDeviceDesc();
   \                     ??usbsrGetDescriptor_0:
   \   000017                ; Setup parameters for call to function usbdpGetDeviceDesc
   \   000017   12....       LCALL   ??usbdpGetDeviceDesc?relay; Banked call to: usbdpGetDeviceDesc
   \   00001A   12....       LCALL   ?Subroutine19 & 0xFFFF
    315                usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
   \                     ??CrossCallReturnLabel_22:
   \   00001D   A3           INC     DPTR
   \   00001E   7B80         MOV     R3,#-0x80
   \   000020   8041         SJMP    ??usbsrGetDescriptor_4
    316                break;
    317          
    318             // Configuration descriptor
    319             case DESC_TYPE_CONFIG:
    320                usbSetupData.pBuffer = (uint8 __code*) usbdpGetConfigurationDesc(0, LO_UINT16(usbSetupHeader.value));
   \                     ??usbsrGetDescriptor_1:
   \   000022                ; Setup parameters for call to function usbdpGetConfigurationDesc
   \   000022   7900         MOV     R1,#0x0
   \   000024   12....       LCALL   ??usbdpGetConfigurationDesc?relay; Banked call to: usbdpGetConfigurationDesc
   \   000027   12....       LCALL   ?Subroutine19 & 0xFFFF
    321                usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_CONFIG_LENGTH_LSB_IDX] +
    322                                         usbSetupData.pBuffer[DESC_CONFIG_LENGTH_MSB_IDX] * 256;
   \                     ??CrossCallReturnLabel_23:
   \   00002A   7B80         MOV     R3,#-0x80
   \   00002C   E9           MOV     A,R1
   \   00002D   2402         ADD     A,#0x2
   \   00002F   F9           MOV     R1,A
   \   000030   E4           CLR     A
   \   000031   3A           ADDC    A,R2
   \   000032   FA           MOV     R2,A
   \   000033   12....       LCALL   ?C_GPTR_LOAD
   \   000036   FC           MOV     R4,A
   \   000037   19           DEC     R1
   \   000038   19           DEC     R1
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FA           MOV     R2,A
   \   00003B   A3           INC     DPTR
   \   00003C   E9           MOV     A,R1
   \   00003D   2403         ADD     A,#0x3
   \   00003F   F9           MOV     R1,A
   \   000040   E4           CLR     A
   \   000041   3A           ADDC    A,R2
   \   000042   FA           MOV     R2,A
   \   000043   12....       LCALL   ?C_GPTR_LOAD
   \   000046   F9           MOV     R1,A
   \   000047   EC           MOV     A,R4
   \   000048   A3           INC     DPTR
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   E9           MOV     A,R1
   \   00004C   801C         SJMP    ??usbsrGetDescriptor_5
    323                break;
    324          
    325             // String descriptor
    326             case DESC_TYPE_STRING:
    327                // TODO: Implement language ID
    328                usbSetupData.pBuffer = (uint8 *)usbdpGetStringDesc(LO_UINT16(usbSetupHeader.value));
   \                     ??usbsrGetDescriptor_2:
   \   00004E                ; Setup parameters for call to function usbdpGetStringDesc
   \   00004E   EA           MOV     A,R2
   \   00004F   F9           MOV     R1,A
   \   000050   12....       LCALL   ??usbdpGetStringDesc?relay; Banked call to: usbdpGetStringDesc
   \   000053   90....       MOV     DPTR,#usbSetupData
   \   000056   EA           MOV     A,R2
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   EB           MOV     A,R3
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   A3           INC     DPTR
   \   00005C   E4           CLR     A
   \   00005D   12....       LCALL   ?Subroutine25 & 0xFFFF
    329                usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
   \                     ??CrossCallReturnLabel_32:
   \   000060   A3           INC     DPTR
   \   000061   7B00         MOV     R3,#0x0
   \                     ??usbsrGetDescriptor_4:
   \   000063   12....       LCALL   ?C_GPTR_LOAD
   \   000066   A3           INC     DPTR
   \   000067   F0           MOVX    @DPTR,A
   \   000068   A3           INC     DPTR
   \   000069   E4           CLR     A
   \                     ??usbsrGetDescriptor_5:
   \   00006A   F0           MOVX    @DPTR,A
    330                break;
   \   00006B   02....       LJMP    ??usbsrGetDescriptor_6 & 0xFFFF
    331          
    332             // Other descriptor type
    333             default:
    334                // Perform a table search (on index and value)
    335                usbSetupData.pBuffer = NULL;
   \                     ??usbsrGetDescriptor_3:
   \   00006E   90....       MOV     DPTR,#usbSetupData
   \   000071   E4           CLR     A
   \   000072   F0           MOVX    @DPTR,A
   \   000073   A3           INC     DPTR
   \   000074   F0           MOVX    @DPTR,A
   \   000075   A3           INC     DPTR
   \   000076   F0           MOVX    @DPTR,A
    336                for (n = 0; n < ((uint16)usbDescriptorMarker.pUsbDescLutEnd - (uint16)usbDescriptorMarker.pUsbDescLut) / sizeof(DESC_LUT_INFO); n++) {
   \   000077   F5..         MOV     ?V3,A
   \   000079   90....       MOV     DPTR,#usbDescriptorMarker + 4
   \   00007C   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   00007F   02....       LJMP    ??usbsrGetDescriptor_7 & 0xFFFF
    337                   if ((usbDescriptorMarker.pUsbDescLut[n].valueMsb == HI_UINT16(usbSetupHeader.value))
    338                       && (usbDescriptorMarker.pUsbDescLut[n].valueLsb == LO_UINT16(usbSetupHeader.value))
    339                       && (usbDescriptorMarker.pUsbDescLut[n].indexMsb == HI_UINT16(usbSetupHeader.index))
    340                       && (usbDescriptorMarker.pUsbDescLut[n].indexLsb == LO_UINT16(usbSetupHeader.index)) )
   \                     ??usbsrGetDescriptor_8:
   \   000082   75..00       MOV     ?V1,#0x0
   \   000085   7403         MOV     A,#0x3
   \   000087   78..         MOV     R0,#?V0
   \   000089   12....       LCALL   ?S_SHL
   \   00008C   EA           MOV     A,R2
   \   00008D   25..         ADD     A,?V0
   \   00008F   F8           MOV     R0,A
   \   000090   EB           MOV     A,R3
   \   000091   35..         ADDC    A,?V1
   \   000093   F9           MOV     R1,A
   \   000094   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000097   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00009A   E4           CLR     A
   \   00009B   93           MOVC    A,@A+DPTR
   \   00009C   C0E0         PUSH    A
   \   00009E   EF           MOV     A,R7
   \   00009F   FC           MOV     R4,A
   \   0000A0   D0E0         POP     A
   \   0000A2   6C           XRL     A,R4
   \   0000A3   705D         JNZ     ??usbsrGetDescriptor_9
   \   0000A5   A3           INC     DPTR
   \   0000A6   E4           CLR     A
   \   0000A7   93           MOVC    A,@A+DPTR
   \   0000A8   6E           XRL     A,R6
   \   0000A9   7057         JNZ     ??usbsrGetDescriptor_9
   \   0000AB   90....       MOV     DPTR,#usbSetupHeader + 4
   \   0000AE   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   0000B1   A3           INC     DPTR
   \   0000B2   A3           INC     DPTR
   \   0000B3   E4           CLR     A
   \   0000B4   93           MOVC    A,@A+DPTR
   \   0000B5   C0E0         PUSH    A
   \   0000B7   EF           MOV     A,R7
   \   0000B8   FC           MOV     R4,A
   \   0000B9   D0E0         POP     A
   \   0000BB   6C           XRL     A,R4
   \   0000BC   7044         JNZ     ??usbsrGetDescriptor_9
   \   0000BE   8882         MOV     DPL,R0
   \   0000C0   8983         MOV     DPH,R1
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   E4           CLR     A
   \   0000C6   93           MOVC    A,@A+DPTR
   \   0000C7   6E           XRL     A,R6
   \   0000C8   7038         JNZ     ??usbsrGetDescriptor_9
    341                   {
    342                      usbSetupData.pBuffer = usbDescriptorMarker.pUsbDescLut[n].pDescStart;
   \   0000CA   8882         MOV     DPL,R0
   \   0000CC   8983         MOV     DPH,R1
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   E4           CLR     A
   \   0000D3   93           MOVC    A,@A+DPTR
   \   0000D4   F5..         MOV     ?V0,A
   \   0000D6   7401         MOV     A,#0x1
   \   0000D8   93           MOVC    A,@A+DPTR
   \   0000D9   F5..         MOV     ?V1,A
   \   0000DB   90....       MOV     DPTR,#usbSetupData
   \   0000DE   E5..         MOV     A,?V0
   \   0000E0   F0           MOVX    @DPTR,A
   \   0000E1   A3           INC     DPTR
   \   0000E2   E5..         MOV     A,?V1
   \   0000E4   F0           MOVX    @DPTR,A
   \   0000E5   A3           INC     DPTR
   \   0000E6   7480         MOV     A,#-0x80
   \   0000E8   F0           MOVX    @DPTR,A
    343                      usbSetupData.bytesLeft = usbDescriptorMarker.pUsbDescLut[n].length;
   \   0000E9   8882         MOV     DPL,R0
   \   0000EB   8983         MOV     DPH,R1
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   A3           INC     DPTR
   \   0000F1   A3           INC     DPTR
   \   0000F2   A3           INC     DPTR
   \   0000F3   E4           CLR     A
   \   0000F4   93           MOVC    A,@A+DPTR
   \   0000F5   F8           MOV     R0,A
   \   0000F6   7401         MOV     A,#0x1
   \   0000F8   93           MOVC    A,@A+DPTR
   \   0000F9   F9           MOV     R1,A
   \   0000FA   90....       MOV     DPTR,#usbSetupData + 3
   \   0000FD   E8           MOV     A,R0
   \   0000FE   F0           MOVX    @DPTR,A
   \   0000FF   A3           INC     DPTR
   \   000100   E9           MOV     A,R1
   \   000101   F0           MOVX    @DPTR,A
    344                   }
    345                }
   \                     ??usbsrGetDescriptor_9:
   \   000102   05..         INC     ?V3
   \                     ??usbsrGetDescriptor_7:
   \   000104   85....       MOV     ?V0,?V3
   \   000107   90....       MOV     DPTR,#usbDescriptorMarker + 6
   \   00010A   12....       LCALL   ?Subroutine14 & 0xFFFF
    346             }
   \                     ??CrossCallReturnLabel_14:
   \   00010D   C3           CLR     C
   \   00010E   9A           SUBB    A,R2
   \   00010F   F5..         MOV     ?V4,A
   \   000111   E9           MOV     A,R1
   \   000112   9B           SUBB    A,R3
   \   000113   F5..         MOV     ?V5,A
   \   000115   7403         MOV     A,#0x3
   \   000117   78..         MOV     R0,#?V4
   \   000119   12....       LCALL   ?US_SHR
   \   00011C   C3           CLR     C
   \   00011D   E5..         MOV     A,?V0
   \   00011F   95..         SUBB    A,?V4
   \   000121   E4           CLR     A
   \   000122   95..         SUBB    A,?V5
   \   000124   5003         JNC     $+5
   \   000126   02....       LJMP    ??usbsrGetDescriptor_8 & 0xFFFF
    347          
    348             // Stall EP0 if no descriptor was found
    349             if (usbSetupData.pBuffer == NULL) usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrGetDescriptor_6:
   \   000129   90....       MOV     DPTR,#usbSetupData
   \   00012C   E0           MOVX    A,@DPTR
   \   00012D   FC           MOV     R4,A
   \   00012E   A3           INC     DPTR
   \   00012F   E0           MOVX    A,@DPTR
   \   000130   FD           MOV     R5,A
   \   000131   A3           INC     DPTR
   \   000132   E0           MOVX    A,@DPTR
   \   000133   FE           MOV     R6,A
   \   000134   EC           MOV     A,R4
   \   000135   4D           ORL     A,R5
   \   000136   4E           ORL     A,R6
   \   000137   90....       MOV     DPTR,#usbfwData + 7
   \   00013A   7004         JNZ     ??usbsrGetDescriptor_10
   \   00013C   7404         MOV     A,#0x4
   \   00013E   8022         SJMP    ??usbsrGetDescriptor_11
    350          
    351             if (usbfwData.ep0Status != EP_STALL) {
   \                     ??usbsrGetDescriptor_10:
   \   000140   E0           MOVX    A,@DPTR
   \   000141   6404         XRL     A,#0x4
   \   000143   601E         JZ      ??usbsrGetDescriptor_12
    352          
    353                // Limit the returned descriptor size (the PC wants to know about sizes before
    354                // polling the complete descriptors)
    355                if (usbSetupData.bytesLeft > usbSetupHeader.length) {
   \   000145   90....       MOV     DPTR,#usbSetupHeader + 6
   \   000148   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00014B   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   00014E   C3           CLR     C
   \   00014F   EA           MOV     A,R2
   \   000150   98           SUBB    A,R0
   \   000151   EB           MOV     A,R3
   \   000152   99           SUBB    A,R1
   \   000153   5008         JNC     ??usbsrGetDescriptor_13
    356                   usbSetupData.bytesLeft = usbSetupHeader.length;
   \   000155   90....       MOV     DPTR,#usbSetupData + 3
   \   000158   EA           MOV     A,R2
   \   000159   F0           MOVX    @DPTR,A
   \   00015A   A3           INC     DPTR
   \   00015B   EB           MOV     A,R3
   \   00015C   F0           MOVX    @DPTR,A
    357                }
    358          
    359                usbfwData.ep0Status = EP_TX;
   \                     ??usbsrGetDescriptor_13:
   \   00015D   90....       MOV     DPTR,#usbfwData + 7
   \   000160   7401         MOV     A,#0x1
   \                     ??usbsrGetDescriptor_11:
   \   000162   F0           MOVX    @DPTR,A
    360             }
    361          
    362          } // usbsrGetDescriptor
   \                     ??usbsrGetDescriptor_12:
   \   000163   7F06         MOV     R7,#0x6
   \   000165   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   90....       MOV     DPTR,#usbSetupData
   \   000003   EA           MOV     A,R2
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   EB           MOV     A,R3
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   7480         MOV     A,#-0x80
   \   00000B   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#usbSetupData
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FA           MOV     R2,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET
    363          
    364          
    365          
    366          /** \brief Internally used function that configures all endpoints for the specified interface
    367           *
    368           * The new endpoint setup overwrites the old, without any warning. Unused endpoints keep their current
    369           * setup. The user is responsible for ensuring that no endpoint buffers overwrite each other, and that
    370           * interfaces do not cause conflicts. The pUsbDblbufLutInfo table must contain an entry for each
    371           * interface descriptor to define endpoint double-buffering.
    372           *
    373           * \param[in]       *pInterface
    374           *     A pointer to the interface descriptor
    375           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    376          static void ConfigureEndpoints(USB_INTERFACE_DESCRIPTOR __code *pInterface)
   \                     ??ConfigureEndpoints:
    377          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 0
    378             uint8 n;
    379             uint16 maxpRegValue;
    380             uint8 csRegValue;
    381             uint8 endpoint;
    382             USB_ENDPOINT_DESCRIPTOR __code *pEndpoint;
    383             DBLBUF_LUT_INFO __code *pUsbDblbufLutInfo;
    384          
    385             // Locate the double buffer settings
    386             if (pInterface->bNumEndpoints) {
   \   000005   EA           MOV     A,R2
   \   000006   2404         ADD     A,#0x4
   \   000008   F5..         MOV     ?V0,A
   \   00000A   E4           CLR     A
   \   00000B   3B           ADDC    A,R3
   \   00000C   F5..         MOV     ?V1,A
   \   00000E   85..82       MOV     DPL,?V0
   \   000011   F583         MOV     DPH,A
   \   000013   E4           CLR     A
   \   000014   93           MOVC    A,@A+DPTR
   \   000015   6025         JZ      ??ConfigureEndpoints_1
    387                 pUsbDblbufLutInfo = (DBLBUF_LUT_INFO __code*) usbDescriptorMarker.pUsbDblbufLut;
   \   000017   90....       MOV     DPTR,#usbDescriptorMarker + 8
   \   00001A   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00001D   FE           MOV     R6,A
   \   00001E   E9           MOV     A,R1
   \   00001F   FF           MOV     R7,A
   \   000020   8007         SJMP    ??ConfigureEndpoints_2
    388                 while (pUsbDblbufLutInfo->pInterface != pInterface) {
    389                    pUsbDblbufLutInfo++;
   \                     ??ConfigureEndpoints_3:
   \   000022   EE           MOV     A,R6
   \   000023   2404         ADD     A,#0x4
   \   000025   FE           MOV     R6,A
   \   000026   5001         JNC     ??ConfigureEndpoints_2
   \   000028   0F           INC     R7
    390                 }
   \                     ??ConfigureEndpoints_2:
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   E4           CLR     A
   \   00002E   93           MOVC    A,@A+DPTR
   \   00002F   F8           MOV     R0,A
   \   000030   7401         MOV     A,#0x1
   \   000032   93           MOVC    A,@A+DPTR
   \   000033   F9           MOV     R1,A
   \   000034   EA           MOV     A,R2
   \   000035   68           XRL     A,R0
   \   000036   7002         JNZ     ??ConfigureEndpoints_4
   \   000038   EB           MOV     A,R3
   \   000039   69           XRL     A,R1
   \                     ??ConfigureEndpoints_4:
   \   00003A   70E6         JNZ     ??ConfigureEndpoints_3
    391             }
    392          
    393             // For each endpoint in this interface
    394             for (n = 0; n < pInterface->bNumEndpoints; n++) {
   \                     ??ConfigureEndpoints_1:
   \   00003C   75..00       MOV     ?V4,#0x0
   \   00003F   803F         SJMP    ??ConfigureEndpoints_5
    395                if (pEndpoint = usbdpFindNext(DESC_TYPE_ENDPOINT, 0)) {
    396          
    397                   // Get the endpoint index
    398                   endpoint = pEndpoint->bEndpointAddress & 0x0F;
    399                   USBFW_SELECT_ENDPOINT(endpoint);
    400          
    401                   csRegValue = 0x00;
    402                   maxpRegValue = (pEndpoint->wMaxPacketSize + 7) >> 3;
    403          
    404                   // For IN endpoints...
    405                   if (pEndpoint->bEndpointAddress & 0x80) {
    406          
    407                      // Clear data toggle, and flush twice (due to double buffering)
    408                      USBCSIL = USBCSIL_CLR_DATA_TOG | USBCSIL_FLUSH_PACKET;
    409                      USBCSIL = USBCSIL_FLUSH_PACKET;
    410          
    411                      // USBCSIH
    412                      if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSIH_ISO;  // ISO flag
    413                      if (pUsbDblbufLutInfo->inMask & (1 << endpoint)) csRegValue |= USBCSIH_IN_DBL_BUF;          // Double buffering
    414                      USBCSIH = csRegValue;
    415          
    416                      // Max transfer size
    417                      USBMAXI = maxpRegValue;
    418          
    419                      // Endpoint status
    420                      usbfwData.pEpInStatus[endpoint - 1] = EP_IDLE;
    421          
    422                   // For OUT endpoints...
    423                   } else {
    424          
    425                      // Clear data toggle, and flush twice (due to double buffering)
    426                      USBCSOL = USBCSOL_CLR_DATA_TOG | USBCSOL_FLUSH_PACKET;
   \                     ??ConfigureEndpoints_6:
   \   000041   906214       MOV     DPTR,#0x6214
   \   000044   7490         MOV     A,#-0x70
   \   000046   F0           MOVX    @DPTR,A
    427                      USBCSOL = USBCSOL_FLUSH_PACKET;
   \   000047   7410         MOV     A,#0x10
   \   000049   12....       LCALL   ?Subroutine21 & 0xFFFF
    428          
    429                      // USBCSOH
    430                      if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSOH_ISO;  // ISO flag
   \                     ??CrossCallReturnLabel_26:
   \   00004C   7003         JNZ     ??ConfigureEndpoints_7
   \   00004E   75..40       MOV     ?V5,#0x40
    431                      if (pUsbDblbufLutInfo->outMask & (1 << endpoint)) csRegValue |= USBCSOH_OUT_DBL_BUF;        // Double buffering
   \                     ??ConfigureEndpoints_7:
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   E4           CLR     A
   \   000059   93           MOVC    A,@A+DPTR
   \   00005A   55..         ANL     A,?V8
   \   00005C   6006         JZ      ??ConfigureEndpoints_8
   \   00005E   E5..         MOV     A,?V5
   \   000060   D2E0         SETB    0xE0 /* A   */.0
   \   000062   F5..         MOV     ?V5,A
    432                      USBCSOH = csRegValue;
   \                     ??ConfigureEndpoints_8:
   \   000064   E5..         MOV     A,?V5
   \   000066   906215       MOV     DPTR,#0x6215
   \   000069   F0           MOVX    @DPTR,A
    433          
    434                      // Max transfer size
    435                      USBMAXO = maxpRegValue;
   \   00006A   EA           MOV     A,R2
   \   00006B   906213       MOV     DPTR,#0x6213
   \   00006E   F0           MOVX    @DPTR,A
    436          
    437                      // Endpoint status
    438                      usbfwData.pEpOutStatus[endpoint - 1] = EP_IDLE;
   \   00006F   EC           MOV     A,R4
   \   000070   240C         ADD     A,#0xc
   \   000072   F582         MOV     DPL,A
   \   000074   E4           CLR     A
   \   000075   3D           ADDC    A,R5
   \   000076   F583         MOV     DPH,A
   \                     ??ConfigureEndpoints_9:
   \   000078   E4           CLR     A
   \   000079   F0           MOVX    @DPTR,A
    439                   }
    440                   USBFW_SELECT_ENDPOINT(0);
   \   00007A   90620E       MOV     DPTR,#0x620e
   \   00007D   F0           MOVX    @DPTR,A
   \                     ??ConfigureEndpoints_10:
   \   00007E   05..         INC     ?V4
   \                     ??ConfigureEndpoints_5:
   \   000080   85..82       MOV     DPL,?V0
   \   000083   85..83       MOV     DPH,?V1
   \   000086   E4           CLR     A
   \   000087   93           MOVC    A,@A+DPTR
   \   000088   F8           MOV     R0,A
   \   000089   E5..         MOV     A,?V4
   \   00008B   C3           CLR     C
   \   00008C   98           SUBB    A,R0
   \   00008D   4003         JC      $+5
   \   00008F   02....       LJMP    ??ConfigureEndpoints_11 & 0xFFFF
   \   000092                ; Setup parameters for call to function usbdpFindNext
   \   000092   7A00         MOV     R2,#0x0
   \   000094   7905         MOV     R1,#0x5
   \   000096   12....       LCALL   ??usbdpFindNext?relay; Banked call to: usbdpFindNext
   \   000099   8A..         MOV     ?V6,R2
   \   00009B   8B..         MOV     ?V7,R3
   \   00009D   EA           MOV     A,R2
   \   00009E   45..         ORL     A,?V7
   \   0000A0   60DC         JZ      ??ConfigureEndpoints_10
   \   0000A2   EA           MOV     A,R2
   \   0000A3   2402         ADD     A,#0x2
   \   0000A5   F8           MOV     R0,A
   \   0000A6   E4           CLR     A
   \   0000A7   35..         ADDC    A,?V7
   \   0000A9   F9           MOV     R1,A
   \   0000AA   88..         MOV     ?V2,R0
   \   0000AC   89..         MOV     ?V3,R1
   \   0000AE   8882         MOV     DPL,R0
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   E4           CLR     A
   \   0000B3   93           MOVC    A,@A+DPTR
   \   0000B4   540F         ANL     A,#0xf
   \   0000B6   F5..         MOV     ?V10,A
   \   0000B8   90620E       MOV     DPTR,#0x620e
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   75..00       MOV     ?V5,#0x0
   \   0000BF   8A82         MOV     DPL,R2
   \   0000C1   8B83         MOV     DPH,R3
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   E4           CLR     A
   \   0000C8   93           MOVC    A,@A+DPTR
   \   0000C9   2407         ADD     A,#0x7
   \   0000CB   F5..         MOV     ?V8,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   E4           CLR     A
   \   0000CF   93           MOVC    A,@A+DPTR
   \   0000D0   3400         ADDC    A,#0x0
   \   0000D2   F5..         MOV     ?V9,A
   \   0000D4   7403         MOV     A,#0x3
   \   0000D6   78..         MOV     R0,#?V8
   \   0000D8   12....       LCALL   ?US_SHR
   \   0000DB   AA..         MOV     R2,?V8
   \   0000DD   85....       MOV     ?V8,?V10
   \   0000E0   74..         MOV     A,#usbfwData & 0xff
   \   0000E2   25..         ADD     A,?V8
   \   0000E4   F8           MOV     R0,A
   \   0000E5   E4           CLR     A
   \   0000E6   34..         ADDC    A,#(usbfwData >> 8) & 0xff
   \   0000E8   F9           MOV     R1,A
   \   0000E9   E8           MOV     A,R0
   \   0000EA   FC           MOV     R4,A
   \   0000EB   E9           MOV     A,R1
   \   0000EC   FD           MOV     R5,A
   \   0000ED   75..01       MOV     ?V8,#0x1
   \   0000F0   75..00       MOV     ?V9,#0x0
   \   0000F3   E5..         MOV     A,?V10
   \   0000F5   78..         MOV     R0,#?V8
   \   0000F7   12....       LCALL   ?S_SHL
   \   0000FA   E5..         MOV     A,?V6
   \   0000FC   2403         ADD     A,#0x3
   \   0000FE   F8           MOV     R0,A
   \   0000FF   E4           CLR     A
   \   000100   35..         ADDC    A,?V7
   \   000102   F9           MOV     R1,A
   \   000103   85..82       MOV     DPL,?V2
   \   000106   85..83       MOV     DPH,?V3
   \   000109   E4           CLR     A
   \   00010A   93           MOVC    A,@A+DPTR
   \   00010B   A2E7         MOV     C,0xE0 /* A   */.7
   \   00010D   4003         JC      $+5
   \   00010F   02....       LJMP    ??ConfigureEndpoints_6 & 0xFFFF
   \   000112   906211       MOV     DPTR,#0x6211
   \   000115   7448         MOV     A,#0x48
   \   000117   F0           MOVX    @DPTR,A
   \   000118   7408         MOV     A,#0x8
   \   00011A   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00011D   7003         JNZ     ??ConfigureEndpoints_12
   \   00011F   75..40       MOV     ?V5,#0x40
   \                     ??ConfigureEndpoints_12:
   \   000122   8E82         MOV     DPL,R6
   \   000124   8F83         MOV     DPH,R7
   \   000126   A3           INC     DPTR
   \   000127   A3           INC     DPTR
   \   000128   E4           CLR     A
   \   000129   93           MOVC    A,@A+DPTR
   \   00012A   55..         ANL     A,?V8
   \   00012C   6006         JZ      ??ConfigureEndpoints_13
   \   00012E   E5..         MOV     A,?V5
   \   000130   D2E0         SETB    0xE0 /* A   */.0
   \   000132   F5..         MOV     ?V5,A
   \                     ??ConfigureEndpoints_13:
   \   000134   E5..         MOV     A,?V5
   \   000136   906212       MOV     DPTR,#0x6212
   \   000139   F0           MOVX    @DPTR,A
   \   00013A   EA           MOV     A,R2
   \   00013B   906210       MOV     DPTR,#0x6210
   \   00013E   F0           MOVX    @DPTR,A
   \   00013F   8C82         MOV     DPL,R4
   \   000141   8D83         MOV     DPH,R5
   \   000143   A3           INC     DPTR
   \   000144   A3           INC     DPTR
   \   000145   A3           INC     DPTR
   \   000146   A3           INC     DPTR
   \   000147   A3           INC     DPTR
   \   000148   A3           INC     DPTR
   \   000149   A3           INC     DPTR
   \   00014A   02....       LJMP    ??ConfigureEndpoints_9 & 0xFFFF
    441                }
    442             }
    443          } // ConfigureEndpoints
   \                     ??ConfigureEndpoints_11:
   \   00014D   7F0B         MOV     R7,#0xb
   \   00014F   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   E4           CLR     A
   \   000006   93           MOVC    A,@A+DPTR
   \   000007   5403         ANL     A,#0x3
   \   000009   6401         XRL     A,#0x1
   \   00000B   22           RET
    444          
    445          
    446          
    447          
    448          /** \brief Processes the \ref GET_CONFIGURATION request (returns the current device configuration value)
    449           *
    450           * If the returned value is 0, the device is not configured (not in the configured state)
    451           *
    452           * <b>Parameters</b>:
    453           * - VALUE: Always 0
    454           * - INDEX: Always 0
    455           * - LENGTH: Always 1
    456           *
    457           * <b>Data (IN)</b>:
    458           * The non-zero \ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue of the currently selected
    459           * configuration.
    460           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    461          void usbsrGetConfiguration(void)
   \                     usbsrGetConfiguration:
    462          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    463          
    464             // Sanity check
    465             if (usbSetupHeader.value || usbSetupHeader.index || (usbSetupHeader.length != 1)) {
   \   000004   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000007   7010         JNZ     ??usbsrGetConfiguration_0
   \   000009   A3           INC     DPTR
   \   00000A   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00000D   700A         JNZ     ??usbsrGetConfiguration_0
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6401         XRL     A,#0x1
   \   000013   7002         JNZ     ??usbsrGetConfiguration_1
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??usbsrGetConfiguration_1:
   \   000017   6007         JZ      ??usbsrGetConfiguration_2
    466                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrGetConfiguration_0:
   \   000019   90....       MOV     DPTR,#usbfwData + 7
   \   00001C   7404         MOV     A,#0x4
   \   00001E   800C         SJMP    ??CrossCallReturnLabel_24
    467          
    468             // Return the current configuration
    469             } else {
    470                usbSetupData.pBuffer = &usbfwData.configurationValue;
   \                     ??usbsrGetConfiguration_2:
   \   000020   90....       MOV     DPTR,#usbSetupData
   \   000023   74..         MOV     A,#(usbfwData + 1) & 0xff
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   74..         MOV     A,#((usbfwData + 1) >> 8) & 0xff
   \   000029   12....       LCALL   ?Subroutine20 & 0xFFFF
    471                usbSetupData.bytesLeft = 1;
    472                usbfwData.ep0Status = EP_TX;
    473             }
   \                     ??CrossCallReturnLabel_24:
   \   00002C   02....       LJMP    ??Subroutine29_0 & 0xFFFF
    474          
    475          } // usbsrGetConfiguration

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E4           CLR     A
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   04           INC     A
   \   000006   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000009   22           RET
    476          
    477          
    478          
    479          
    480          /** \brief Processes the \ref SET_CONFIGURATION request (sets the device configuration)
    481           *
    482           * The configuration value must either be 0, in which case the device enters the address state, or it
    483           * must match a configuration value from one of the USB configuration descriptors. If there is a match,
    484           * the device enters the configured state.
    485           *
    486           * This request resets all interfaces to alternate setting 0, and uses the \c ConfigureEndpoints()
    487           * function to automatically setup all endpoint registers.
    488           *
    489           * <b>Parameters</b>:
    490           * - VALUE: The configuration value (0-255)
    491           * - INDEX: Always 0
    492           * - LENGTH: Always 0
    493           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    494          void usbsrSetConfiguration(void)
   \                     usbsrSetConfiguration:
    495          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    496             uint8 n;
    497             USB_CONFIGURATION_DESCRIPTOR __code *pConfiguration;
    498             USB_INTERFACE_DESCRIPTOR __code *pInterface;
    499          
    500             // Sanity check
    501             if ((usbfwData.usbState == DEV_DEFAULT) || usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value)) {
   \   000005   90....       MOV     DPTR,#usbfwData
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6402         XRL     A,#0x2
   \   00000B   6014         JZ      ??usbsrSetConfiguration_0
   \   00000D   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000010   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000013   700C         JNZ     ??usbsrSetConfiguration_0
   \   000015   A3           INC     DPTR
   \   000016   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000019   7006         JNZ     ??usbsrSetConfiguration_0
   \   00001B   90....       MOV     DPTR,#usbSetupHeader + 3
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6008         JZ      ??usbsrSetConfiguration_1
    502                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetConfiguration_0:
   \   000021   90....       MOV     DPTR,#usbfwData + 7
   \   000024   7404         MOV     A,#0x4
   \   000026   F0           MOVX    @DPTR,A
   \   000027   807B         SJMP    ??usbsrSetConfiguration_2
    503          
    504             // Default endpoint setup
    505             } else {
    506                usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGING, 0);
   \                     ??usbsrSetConfiguration_1:
   \   000029                ; Setup parameters for call to function usbsrHookProcessEvent
   \   000029   7A00         MOV     R2,#0x0
   \   00002B   7901         MOV     R1,#0x1
   \   00002D   12....       LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
    507          
    508                // Configure relevant endpoints
    509                if (LO_UINT16(usbSetupHeader.value)) {
   \   000030   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FE           MOV     R6,A
   \   000035   6058         JZ      ??usbsrSetConfiguration_3
    510          
    511                   // Find the correct configuration descriptor...
    512                   pConfiguration = usbdpGetConfigurationDesc(LO_UINT16(usbSetupHeader.value), 0);
   \   000037                ; Setup parameters for call to function usbdpGetConfigurationDesc
   \   000037   7A00         MOV     R2,#0x0
   \   000039   F9           MOV     R1,A
   \   00003A   12....       LCALL   ??usbdpGetConfigurationDesc?relay; Banked call to: usbdpGetConfigurationDesc
   \   00003D   8A..         MOV     ?V0,R2
   \   00003F   8B..         MOV     ?V1,R3
    513          
    514                   // If it exists...
    515                   if (pConfiguration) {
   \   000041   EA           MOV     A,R2
   \   000042   45..         ORL     A,?V1
   \   000044   6041         JZ      ??usbsrSetConfiguration_4
    516                      usbfwData.usbState = DEV_CONFIGURED;
   \   000046   90....       MOV     DPTR,#usbfwData
   \   000049   7404         MOV     A,#0x4
   \   00004B   F0           MOVX    @DPTR,A
    517                      usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
   \   00004C   EE           MOV     A,R6
   \   00004D   A3           INC     DPTR
   \   00004E   F0           MOVX    @DPTR,A
    518          
    519                      // For each interface...
    520                      for (n = 0; n < pConfiguration->bNumInterfaces; n++) {
   \   00004F   7E00         MOV     R6,#0x0
   \                     ??usbsrSetConfiguration_5:
   \   000051   85..82       MOV     DPL,?V0
   \   000054   85..83       MOV     DPH,?V1
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   E4           CLR     A
   \   00005C   93           MOVC    A,@A+DPTR
   \   00005D   F8           MOV     R0,A
   \   00005E   EE           MOV     A,R6
   \   00005F   C3           CLR     C
   \   000060   98           SUBB    A,R0
   \   000061   503A         JNC     ??usbsrSetConfiguration_6
    521                         usbfwData.pAlternateSetting[n] = 0x00;
   \   000063   74..         MOV     A,#(usbfwData + 2) & 0xff
   \   000065   2E           ADD     A,R6
   \   000066   F582         MOV     DPL,A
   \   000068   E4           CLR     A
   \   000069   34..         ADDC    A,#((usbfwData + 2) >> 8) & 0xff
   \   00006B   F583         MOV     DPH,A
   \   00006D   E4           CLR     A
   \   00006E   F0           MOVX    @DPTR,A
    522          
    523                         // Look only for alternate setting 0
    524                         do {
    525                            pInterface = usbdpFindNext(DESC_TYPE_INTERFACE, 0);
   \                     ??usbsrSetConfiguration_7:
   \   00006F                ; Setup parameters for call to function usbdpFindNext
   \   00006F   7A00         MOV     R2,#0x0
   \   000071   7904         MOV     R1,#0x4
   \   000073   12....       LCALL   ??usbdpFindNext?relay; Banked call to: usbdpFindNext
    526                         } while (pInterface->bAlternateSetting != usbfwData.pAlternateSetting[n]);
   \   000076   8A82         MOV     DPL,R2
   \   000078   8B83         MOV     DPH,R3
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   E4           CLR     A
   \   00007E   93           MOVC    A,@A+DPTR
   \   00007F   70EE         JNZ     ??usbsrSetConfiguration_7
    527          
    528                         // Configure all endpoints in this interface
    529                         ConfigureEndpoints(pInterface);
   \   000081                ; Setup parameters for call to function ConfigureEndpoints
   \   000081   12....       LCALL   ??ConfigureEndpoints?relay; Banked call to: ConfigureEndpoints
    530                      }
   \   000084   0E           INC     R6
   \   000085   80CA         SJMP    ??usbsrSetConfiguration_5
    531          
    532                   // If not, then stall the endpoint
    533                   } else {
    534                      usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetConfiguration_4:
   \   000087   90....       MOV     DPTR,#usbfwData + 7
   \   00008A   7404         MOV     A,#0x4
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D   800E         SJMP    ??usbsrSetConfiguration_6
    535                   }
    536          
    537                // Unconfigure endpoints
    538                } else {
    539                   usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
   \                     ??usbsrSetConfiguration_3:
   \   00008F   90....       MOV     DPTR,#usbfwData + 1
   \   000092   F0           MOVX    @DPTR,A
    540                   usbfwData.usbState = DEV_ADDRESS;
   \   000093   90....       MOV     DPTR,#usbfwData
   \   000096   7403         MOV     A,#0x3
   \   000098   F0           MOVX    @DPTR,A
    541                   usbfwSetAllEpStatus(EP_HALT);
   \   000099                ; Setup parameters for call to function usbfwSetAllEpStatus
   \   000099   F9           MOV     R1,A
   \   00009A   12....       LCALL   ??usbfwSetAllEpStatus?relay; Banked call to: usbfwSetAllEpStatus
    542                }
    543                usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGED, 0);
   \                     ??usbsrSetConfiguration_6:
   \   00009D                ; Setup parameters for call to function usbsrHookProcessEvent
   \   00009D   7A00         MOV     R2,#0x0
   \   00009F   7902         MOV     R1,#0x2
   \   0000A1   12....       LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
    544             }
    545          
    546          } // usbsrSetConfiguration
   \                     ??usbsrSetConfiguration_2:
   \   0000A4   02....       LJMP    ?Subroutine0 & 0xFFFF
    547          
    548          
    549          
    550          
    551          /** \brief Processes the \ref GET_INTERFACE request (returns the selected alternate setting for the
    552           * specified interface)
    553           *
    554           * Some USB devices have configurations with mutually exclusive interface settings. This request allows
    555           * the host to determine the currently selected alternate setting.
    556           *
    557           * <b>Parameters</b>:
    558           * - VALUE: Always 0
    559           * - INDEX: Interface number
    560           * - LENGTH: Always 1
    561           *
    562           * <b>Data (IN)</b>:
    563           * The alternate setting for the selected interface
    564           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    565          void usbsrGetInterface(void)
   \                     usbsrGetInterface:
    566          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    567          
    568             // Sanity check
    569             if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_IN_INTERFACE) || usbSetupHeader.value || (usbSetupHeader.length != 1)) {
   \   000005   90....       MOV     DPTR,#usbfwData
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6404         XRL     A,#0x4
   \   00000B   7019         JNZ     ??usbsrGetInterface_0
   \   00000D   90....       MOV     DPTR,#usbSetupHeader
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6481         XRL     A,#0x81
   \   000013   7011         JNZ     ??usbsrGetInterface_0
   \   000015   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000018   700C         JNZ     ??usbsrGetInterface_0
   \   00001A   90....       MOV     DPTR,#usbSetupHeader + 6
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   6401         XRL     A,#0x1
   \   000020   7002         JNZ     ??usbsrGetInterface_1
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \                     ??usbsrGetInterface_1:
   \   000024   6007         JZ      ??usbsrGetInterface_2
    570                usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrGetInterface_0:
   \   000026   90....       MOV     DPTR,#usbfwData + 7
   \   000029   7404         MOV     A,#0x4
   \   00002B   801A         SJMP    ??CrossCallReturnLabel_25
    571          
    572             // Return the current alternate setting
    573             } else {
    574                usbSetupData.pBuffer = &usbfwData.pAlternateSetting[usbSetupHeader.index];
   \                     ??usbsrGetInterface_2:
   \   00002D   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000030   E0           MOVX    A,@DPTR
   \   000031   24..         ADD     A,#(usbfwData + 2) & 0xff
   \   000033   F5..         MOV     ?V0,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   34..         ADDC    A,#((usbfwData + 2) >> 8) & 0xff
   \   000039   F5..         MOV     ?V1,A
   \   00003B   90....       MOV     DPTR,#usbSetupData
   \   00003E   E5..         MOV     A,?V0
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   E5..         MOV     A,?V1
   \   000044   12....       LCALL   ?Subroutine20 & 0xFFFF
    575                usbSetupData.bytesLeft = 1;
    576                usbfwData.ep0Status = EP_TX;
    577             }
   \                     ??CrossCallReturnLabel_25:
   \   000047   02....       LJMP    ?Subroutine3 & 0xFFFF
    578          
    579          } // usbsrGetInterface
    580          
    581          
    582          
    583          
    584          /** \brief Processes the \ref SET_INTERFACE request (selects an alternate setting for the specified
    585           * interface)
    586           *
    587           * Some USB devices have configurations with mutually exclusive interface settings. This request allows
    588           * the host to select the desired alternate setting.
    589           *
    590           * This function uses the \c ConfigureEndpoints() to automatically setup the relevant endpoint
    591           * registers.
    592           *
    593           * <b>Parameters</b>:
    594           * - VALUE: Alternate setting
    595           * - INDEX: Interface number
    596           * - LENGTH: Always 0
    597           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    598          void usbsrSetInterface(void)
   \                     usbsrSetInterface:
    599          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    600             USB_INTERFACE_DESCRIPTOR __code *pInterface;
    601          
    602             // Sanity check
    603             if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_OUT_INTERFACE) || usbSetupHeader.length) {
   \   000005   90....       MOV     DPTR,#usbfwData
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6404         XRL     A,#0x4
   \   00000B   7060         JNZ     ??usbsrSetInterface_0
   \   00000D   90....       MOV     DPTR,#usbSetupHeader
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6401         XRL     A,#0x1
   \   000013   7058         JNZ     ??usbsrSetInterface_0
   \   000015   90....       MOV     DPTR,#usbSetupHeader + 6
   \   000018   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00001B   7050         JNZ     ??usbsrSetInterface_0
    604                usbfwData.ep0Status = EP_STALL;
    605          
    606             // Verify that the desired alternate setting is available, and then make the switch
    607             } else {
    608                if (pInterface = usbdpGetInterfaceDesc(usbfwData.configurationValue, usbSetupHeader.index, usbSetupHeader.value)) {
   \   00001D   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000020   E0           MOVX    A,@DPTR
   \   000021   FE           MOV     R6,A
   \   000022                ; Setup parameters for call to function usbdpGetInterfaceDesc
   \   000022   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000025   E0           MOVX    A,@DPTR
   \   000026   FB           MOV     R3,A
   \   000027   EE           MOV     A,R6
   \   000028   FA           MOV     R2,A
   \   000029   90....       MOV     DPTR,#usbfwData + 1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F9           MOV     R1,A
   \   00002E   12....       LCALL   ??usbdpGetInterfaceDesc?relay; Banked call to: usbdpGetInterfaceDesc
   \   000031   8A..         MOV     ?V0,R2
   \   000033   8B..         MOV     ?V1,R3
   \   000035   EA           MOV     A,R2
   \   000036   45..         ORL     A,?V1
   \   000038   6033         JZ      ??usbsrSetInterface_0
    609                   usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGING, usbSetupHeader.index);
   \   00003A                ; Setup parameters for call to function usbsrHookProcessEvent
   \   00003A   EE           MOV     A,R6
   \   00003B   FA           MOV     R2,A
   \   00003C   7903         MOV     R1,#0x3
   \   00003E   12....       LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
    610                   usbfwData.pAlternateSetting[usbSetupHeader.index] = usbSetupHeader.value;
   \   000041   90....       MOV     DPTR,#usbSetupHeader + 2
   \   000044   E0           MOVX    A,@DPTR
   \   000045   C0E0         PUSH    A
   \   000047   90....       MOV     DPTR,#usbSetupHeader + 4
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   24..         ADD     A,#(usbfwData + 2) & 0xff
   \   00004D   F8           MOV     R0,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   34..         ADDC    A,#((usbfwData + 2) >> 8) & 0xff
   \   000052   F9           MOV     R1,A
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   D0E0         POP     A
   \   000059   F0           MOVX    @DPTR,A
    611          
    612                   // Configure all endpoints in this interface
    613                   ConfigureEndpoints(pInterface);
   \   00005A                ; Setup parameters for call to function ConfigureEndpoints
   \   00005A   AA..         MOV     R2,?V0
   \   00005C   AB..         MOV     R3,?V1
   \   00005E   12....       LCALL   ??ConfigureEndpoints?relay; Banked call to: ConfigureEndpoints
    614                   usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGED, usbSetupHeader.index);
   \   000061                ; Setup parameters for call to function usbsrHookProcessEvent
   \   000061   90....       MOV     DPTR,#usbSetupHeader + 4
   \   000064   E0           MOVX    A,@DPTR
   \   000065   FA           MOV     R2,A
   \   000066   7904         MOV     R1,#0x4
   \   000068   12....       LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
   \   00006B   8006         SJMP    ??usbsrSetInterface_1
    615          
    616                // This interface does not exist
    617                } else {
    618                   usbfwData.ep0Status = EP_STALL;
   \                     ??usbsrSetInterface_0:
   \   00006D   90....       MOV     DPTR,#usbfwData + 7
   \   000070   7404         MOV     A,#0x4
   \   000072   F0           MOVX    @DPTR,A
    619                }
    620             }
    621          
    622          } // usbsrSetInterface
   \                     ??usbsrSetInterface_1:
   \   000073   02....       LJMP    ?Subroutine0 & 0xFFFF
    623          
    624          //@}
    625          
    626          /*
    627          +------------------------------------------------------------------------------
    628          |  Copyright 2004-2010 Texas Instruments Incorporated. All rights reserved.
    629          |
    630          |  IMPORTANT: Your use of this Software is limited to those specific rights
    631          |  granted under the terms of a software license agreement between the user who
    632          |  downloaded the software, his/her employer (which must be your employer) and
    633          |  Texas Instruments Incorporated (the "License"). You may not use this Software
    634          |  unless you agree to abide by the terms of the License. The License limits
    635          |  your use, and you acknowledge, that the Software may not be modified, copied
    636          |  or distributed unless embedded on a Texas Instruments microcontroller or used
    637          |  solely and exclusively in conjunction with a Texas Instruments radio
    638          |  frequency transceiver, which is integrated into your product. Other than for
    639          |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
    640          |  works of, modify, distribute, perform, display or sell this Software and/or
    641          |  its documentation for any purpose.
    642          |
    643          |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
    644          |  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
    645          |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
    646          |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
    647          |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
    648          |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
    649          |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
    650          |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
    651          |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
    652          |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
    653          |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
    654          |
    655          |  Should you have any questions regarding your right to use this Software,
    656          |  contact Texas Instruments Incorporated at www.TI.com.
    657          |
    658          +------------------------------------------------------------------------------
    659          */
E:\mgzhou\Study\CC2540\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_suspend.c
      1          /***********************************************************************************
      2          
      3              Filename:     usb_suspend.c
      4          
      5              Description:  USB library common functionality.
      6          
      7          ***********************************************************************************/
      8          
      9          /// \addtogroup module_usb_suspend
     10          /// @{
     11          #include "usb_firmware_library_headers.h"
     12          #include "hal_board.h"
     13          #include "hal_mcu.h"
     14          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     15          __xdata VFPTR pFnSuspendEnterHook=  NULL;
   \                     pFnSuspendEnterHook:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     16          __xdata VFPTR pFnSuspendExitHook=   NULL;
   \                     pFnSuspendExitHook:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     17          
     18          #if HAL_UART_USB_SUSPEND
     19          extern void halEnterPowerMode(void);
     20          
     21          /** \brief Puts the chip into power mode 1 during USB suspend.
     22           *
     23           * This function must be called from main (i.e. not from interrupt context) upon the reception of a
     24           * \ref USBIRQ_EVENT_SUSPEND event. To comply with the USB specification, this must happen within 10 ms
     25           * after the event occurs. The chip will stay in power mode 1 until a USB resume or USB reset is detected
     26           * on the USB bus, or remote wakeup is used. During this period, the MCU can only run code from
     27           * interrupt context.
     28           */
     29          void usbsuspEnter(void)
     30          {
     31              if (pFnSuspendEnterHook!=NULL)
     32                  pFnSuspendEnterHook();
     33          
     34              HAL_USB_INT_CLEAR();
     35              HAL_USB_INT_ENABLE();
     36          
     37              // Disable USB clock (PLL) before entering PM1
     38              HAL_USB_PLL_DISABLE();
     39          
     40              HAL_LED_CLR_1();
     41          
     42              do {
     43                  // Enter PM1, in prescribed manner as explained in CC253x User's Guide
     44                  SLEEPCMD = 0x05;
     45                  halEnterPowerMode();
     46              } while ( usbirqData.inSuspend );
     47          
     48              // .... we are now up and running again
     49          
     50              // First make sure that the crystal oscillator is stable
     51              while (!CC2530_IS_XOSC_STABLE());
     52          
     53              // Restart the USB clock (PLL)
     54              HAL_USB_ENABLE();
     55          
     56              if (pFnSuspendExitHook!=NULL)
     57                  pFnSuspendExitHook();
     58          } // usbsuspEnter
     59          #endif
     60          
     61          
     62          
     63          /** \brief Attempts USB remote wakeup.
     64           *
     65           * This function can be called from interrupt context while the USB device is suspend mode. If the device
     66           * is privileged to do so (see \c usbfwData.remoteWakeup and the \ref USBSR_EVENT_REMOTE_WAKEUP_ENABLED
     67           * and \ref USBSR_EVENT_REMOTE_WAKEUP_DISABLED events), remote wakeup will be performed. Note that this
     68           * function will block for 10 ms while the resume signal is set on the bus. Note: This function can only
     69           * be called when the 48 MHz XOSC is stable.
     70           *
     71           * \return
     72           *     \c TRUE if the remote wakeup was performed (the privilege had been granted), otherwise \c FALSE
     73           *     (the device is still in suspend mode).
     74           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     75          uint8 usbsuspDoRemoteWakeup(void)
   \                     usbsuspDoRemoteWakeup:
     76          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
     77             extern void halMcuWaitMs(uint16 msec);
     78             halIntState_t   intState;
     79          
     80             // Make sure that it's OK
     81             if (!usbfwData.remoteWakeup) return FALSE;
   \   000005   90....       MOV     DPTR,#usbfwData + 18
   \   000008   E0           MOVX    A,@DPTR
   \   000009   7004         JNZ     ??usbsuspDoRemoteWakeup_0
   \   00000B   7900         MOV     R1,#0x0
   \   00000D   802B         SJMP    ??usbsuspDoRemoteWakeup_1
     82          
     83             HAL_ENTER_CRITICAL_SECTION(intState);
   \                     ??usbsuspDoRemoteWakeup_0:
   \   00000F   E5A8         MOV     A,0xa8
   \   000011   FE           MOV     R6,A
   \   000012   C2AF         CLR     0xa8.7
     84          
     85             // Make sure that the suspend loop does not power down the chip again
     86             usbirqData.inSuspend = FALSE;
   \   000014   75..00       MOV     usbirqData + 2,#0x0
     87          
     88             // Perform remote wakeup by holding the USB resume signal for 10 ms
     89             USBPOW |= USBPOW_RESUME;
   \   000017   906201       MOV     DPTR,#0x6201
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   D2E2         SETB    0xE0 /* A   */.2
   \   00001D   F0           MOVX    @DPTR,A
     90             halMcuWaitMs(10);
   \   00001E                ; Setup parameters for call to function halMcuWaitMs
   \   00001E   7A0A         MOV     R2,#0xa
   \   000020   7B00         MOV     R3,#0x0
   \   000022   12....       LCALL   ??halMcuWaitMs?relay ; Banked call to: halMcuWaitMs
     91             USBPOW &= ~USBPOW_RESUME;
   \   000025   906201       MOV     DPTR,#0x6201
   \   000028   E0           MOVX    A,@DPTR
   \   000029   C2E2         CLR     0xE0 /* A   */.2
   \   00002B   F0           MOVX    @DPTR,A
     92          
     93             // Clear the interrupt flag
     94             HAL_USB_INT_CLEAR();
   \   00002C   758B00       MOV     0x8b,#0x0
   \   00002F   C2E8         CLR     0xe8.0
     95          
     96             HAL_EXIT_CRITICAL_SECTION(intState);
   \   000031   EE           MOV     A,R6
   \   000032   A2E7         MOV     C,0xE0 /* A   */.7
   \   000034   A2E7         MOV     C,0xE0 /* A   */.7
   \   000036   92AF         MOV     0xa8.7,C
     97          
     98             return TRUE;
   \   000038   7901         MOV     R1,#0x1
   \                     ??usbsuspDoRemoteWakeup_1:
   \   00003A   02....       LJMP    ?Subroutine4 & 0xFFFF
   \   00003D                REQUIRE _A_IEN0
   \   00003D                REQUIRE P2IFG
   \   00003D                REQUIRE _A_IRCON2
     99          
    100          } // usbsuspDoRemoteWakeup

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   90....       MOV     DPTR,#usbDescriptorMarker
   \   000003   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000006   90....       MOV     DPTR,#??usbdpData
   \   000009   E8           MOV     A,R0
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   E9           MOV     A,R1
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for serialNumber>`:
   \   000000   00           DB 0
   \   000001   03           DB 3
   \   000002   5F           DB 95
   \   000003   00           DB 0
   \   000004   5F           DB 95
   \   000005   00           DB 0
   \   000006   30           DB 48
   \   000007   00           DB 0
   \   000008   58           DB 88
   \   000009   00           DB 0
   \   00000A   00           DB 0
   \   00000B   00           DB 0
   \   00000C   00           DB 0
   \   00000D   00           DB 0
   \   00000E   00           DB 0
   \   00000F   00           DB 0
   \   000010   00           DB 0
   \   000011   00           DB 0
   \   000012   00           DB 0
   \   000013   00           DB 0
   \   000014   00           DB 0
   \   000015   00           DB 0
   \   000016   00           DB 0
   \   000017   00           DB 0
   \   000018   00           DB 0
   \   000019   00           DB 0
   \   00001A   00           DB 0
   \   00001B   00           DB 0
   \   00001C   00           DB 0
   \   00001D   00           DB 0
   \   00001E   00           DB 0
   \   00001F   00           DB 0
   \   000020   00           DB 0
   \   000021   00           DB 0
   \   000022   00           DB 0
   \   000023   00           DB 0
   \   000024   00           DB 0
   \   000025   00           DB 0
   \   000026   00           DB 0
   \   000027   00           DB 0
   \   000028   00           DB 0
   \   000029   00           DB 0

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalFlashRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalFlashWrite?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalFlashErase?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashErase

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ublAesAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublAesAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ublAesCrypt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublAesCrypt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ublCfg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublCfg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ublExec?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublExec

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ublInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ublJump?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublJump

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ublMassErase?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ublMassErase

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gpioInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??gpioInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??main?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    main

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbdpInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbdpFindNext?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpFindNext

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbdpGetDeviceDesc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpGetDeviceDesc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbdpGetConfigurationDesc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpGetConfigurationDesc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbdpGetInterfaceDesc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpGetInterfaceDesc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbdpGetStringDesc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbdpGetStringDesc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbfwInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbfwResetHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwResetHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbfwSetupHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwSetupHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbfwSetAllEpStatus?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwSetAllEpStatus

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbfwReadFifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwReadFifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbfwWriteFifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbfwWriteFifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbirqInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbirqInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbirqHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbirqHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbsrGetStatus?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrGetStatus

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ChangeFeature?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??ChangeFeature

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbsrClearFeature?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrClearFeature

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbsrSetFeature?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrSetFeature

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbsrSetAddress?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrSetAddress

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbsrGetDescriptor?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrGetDescriptor

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ConfigureEndpoints?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??ConfigureEndpoints

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbsrGetConfiguration?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrGetConfiguration

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbsrSetConfiguration?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrSetConfiguration

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbsrGetInterface?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrGetInterface

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbsrSetInterface?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsrSetInterface

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??usbsuspDoRemoteWakeup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    usbsuspDoRemoteWakeup

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255}>`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255}>_1`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255, 255, 255, 255,`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_7d:
   \   000000   7D000000     DD 125
    101          
    102          
    103          
    104          //@}
    105          /*
    106          +------------------------------------------------------------------------------
    107          |  Copyright 2004-2012 Texas Instruments Incorporated. All rights reserved.
    108          |
    109          |  IMPORTANT: Your use of this Software is limited to those specific rights
    110          |  granted under the terms of a software license agreement between the user who
    111          |  downloaded the software, his/her employer (which must be your employer) and
    112          |  Texas Instruments Incorporated (the "License"). You may not use this Software
    113          |  unless you agree to abide by the terms of the License. The License limits
    114          |  your use, and you acknowledge, that the Software may not be modified, copied
    115          |  or distributed unless embedded on a Texas Instruments microcontroller or used
    116          |  solely and exclusively in conjunction with a Texas Instruments radio
    117          |  frequency transceiver, which is integrated into your product. Other than for
    118          |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
    119          |  works of, modify, distribute, perform, display or sell this Software and/or
    120          |  its documentation for any purpose.
    121          |
    122          |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
    123          |  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
    124          |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
    125          |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
    126          |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
    127          |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
    128          |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
    129          |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
    130          |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
    131          |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
    132          |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
    133          |
    134          |  Should you have any questions regarding your right to use this Software,
    135          |  contact Texas Instruments Incorporated at www.TI.com.
    136          |
    137          +------------------------------------------------------------------------------
    138          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     10   ChangeFeature
        0     10   -> usbsrHookProcessEvent
      0     31   ConfigureEndpoints
        0     19   -> usbdpFindNext
      2      0   HalFlashErase
      1     34   HalFlashRead
      0     32   HalFlashWrite
      0     11   __low_level_init
        0     11   -> HalFlashRead
        0      9   -> ublJump
      1     30   gpioInit
      0      0   main
        0      0   -> ublExec
        0      0   -> ublInit
      0     12   ublAesAuth
        0     12   -> HalFlashRead
        0     12   -> HalFlashWrite
      0      0   ublAesCrypt
      0     16   ublCfg
        0     16   -> HalFlashWrite
        0     16   -> memcmp
        0     16   -> memcpy
        0     14   -> ublMassErase
      1     16   ublExec
        0     16   -> ublJump
        0     16   -> usb_msd_poll
        0     16   -> usb_msd_uninit
      0     22   ublInit
        0     22   -> HalFlashRead
        0     22   -> HalFlashWrite
        0     20   -> gpioInit
        0     22   -> memcmp
        0     20   -> ublJump
        0     20   -> usb_msd_init
      0     20   ublJump
      3     14   ublMassErase
      2     19   usbdpFindNext
      0     24   usbdpGetConfigurationDesc
        0     10   -> usbdpFindNext
      2     14   usbdpGetDeviceDesc
        2      0   -> usbdpFindNext
      0     24   usbdpGetInterfaceDesc
        0     12   -> usbdpFindNext
        0     12   -> usbdpGetConfigurationDesc
      1     32   usbdpGetStringDesc
      2      0   usbdpInit
      2      0   usbfwInit
        2      0   -> usbdpGetConfigurationDesc
      1     23   usbfwReadFifo
      2      0   usbfwResetHandler
        2      0   -> usbfwSetAllEpStatus
      1     22   usbfwSetAllEpStatus
      0     14   usbfwSetupHandler
        0     11   -> usbcrHookProcessIn
        0     11   -> usbcrHookProcessOut
        0     14   -> usbfwReadFifo
        0     14   -> usbfwWriteFifo
        0     11   -> usbsrClearFeature
        0     11   -> usbsrGetConfiguration
        0     11   -> usbsrGetDescriptor
        0     11   -> usbsrGetInterface
        0     11   -> usbsrGetStatus
        0     11   -> usbsrSetAddress
        0     11   -> usbsrSetConfiguration
        0     11   -> usbsrSetFeature
        0     11   -> usbsrSetInterface
        0     11   -> usbvrHookProcessIn
        0     11   -> usbvrHookProcessOut
      1     23   usbfwWriteFifo
      0     10   usbirqHandler
        0     10   -> usbirqHookProcessEvents
      0     10   usbirqInit
      2     11   usbsrClearFeature
        2      0   -> ChangeFeature
        2      0   -> usbsrHookClearFeature
      2     11   usbsrGetConfiguration
      1     25   usbsrGetDescriptor
        0     14   -> usbdpGetConfigurationDesc
        0     14   -> usbdpGetDeviceDesc
        0     14   -> usbdpGetStringDesc
      0     22   usbsrGetInterface
      0     21   usbsrGetStatus
      2     11   usbsrSetAddress
      0     23   usbsrSetConfiguration
        0     12   -> ConfigureEndpoints
        0     12   -> usbdpFindNext
        0     12   -> usbdpGetConfigurationDesc
        0     12   -> usbfwSetAllEpStatus
        0     12   -> usbsrHookProcessEvent
      2     11   usbsrSetFeature
        2      0   -> ChangeFeature
        2      0   -> usbsrHookSetFeature
      1     23   usbsrSetInterface
        0     12   -> ConfigureEndpoints
        0     12   -> usbdpGetInterfaceDesc
        0     12   -> usbsrHookProcessEvent
      0      9   usbsuspDoRemoteWakeup
        0      9   -> halMcuWaitMs


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {255, 255, 255, 255, 255, 255, 255,
       4  ?<Constant {255, 255, 255, 255}>
       4  ?<Constant {255, 255, 255, 255}>_1
      42  ?<Initializer for serialNumber>
       6  ??ChangeFeature?relay
       6  ??ConfigureEndpoints?relay
       6  ??HalFlashErase?relay
       6  ??HalFlashRead?relay
       6  ??HalFlashWrite?relay
       5  ??Subroutine27_0
       4  ??Subroutine28_0
       1  ??Subroutine29_0
       7  ??Subroutine30_0
       3  ??Subroutine31_0
       6  ??Subroutine32_0
       6  ??Subroutine33_0
       6  ??gpioInit?relay
       6  ??main?relay
       6  ??ublAesAuth?relay
       6  ??ublAesCrypt?relay
       6  ??ublCfg?relay
       6  ??ublExec?relay
       6  ??ublInit?relay
       6  ??ublJump?relay
       6  ??ublMassErase?relay
       6  ??usbdpFindNext?relay
       6  ??usbdpGetConfigurationDesc?relay
       6  ??usbdpGetDeviceDesc?relay
       6  ??usbdpGetInterfaceDesc?relay
       6  ??usbdpGetStringDesc?relay
       6  ??usbdpInit?relay
       6  ??usbfwInit?relay
       6  ??usbfwReadFifo?relay
       6  ??usbfwResetHandler?relay
       6  ??usbfwSetAllEpStatus?relay
       6  ??usbfwSetupHandler?relay
       6  ??usbfwWriteFifo?relay
       6  ??usbirqHandler?relay
       6  ??usbirqInit?relay
       6  ??usbsrClearFeature?relay
       6  ??usbsrGetConfiguration?relay
       6  ??usbsrGetDescriptor?relay
       6  ??usbsrGetInterface?relay
       6  ??usbsrGetStatus?relay
       6  ??usbsrSetAddress?relay
       6  ??usbsrSetConfiguration?relay
       6  ??usbsrSetFeature?relay
       6  ??usbsrSetInterface?relay
       6  ??usbsuspDoRemoteWakeup?relay
       5  ?Subroutine0
       5  ?Subroutine1
       7  ?Subroutine10
      15  ?Subroutine11
      18  ?Subroutine12
      10  ?Subroutine13
       5  ?Subroutine14
       3  ?Subroutine15
       8  ?Subroutine16
      10  ?Subroutine17
      11  ?Subroutine18
      15  ?Subroutine19
       7  ?Subroutine2
      10  ?Subroutine20
      12  ?Subroutine21
      17  ?Subroutine22
       6  ?Subroutine23
       9  ?Subroutine24
      10  ?Subroutine25
       9  ?Subroutine26
       6  ?Subroutine3
       5  ?Subroutine4
       6  ?Subroutine5
      15  ?Subroutine6
       3  ?Subroutine7
      29  ?Subroutine8
       3  ?Subroutine9
       1  ADCCON1
       1  ADCCON3
       1  ADCH
       1  CLKCONCMD
     236  ChangeFeature
     338  ConfigureEndpoints
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMAARM
       1  DMAIRQ
      13  HalFlashErase
     129  HalFlashRead
      94  HalFlashWrite
       1  IEN2
       1  MEMCTR
       1  P2IFG
       1  P2INP
       2  ProcessFunc
       1  SLEEPSTA
       1  ST0
       1  ST1
       1  ST2
       1  UBL_RC_IMG_PG_BEG
       1  UBL_RC_IMG_PG_END
       1  WDCTL
       1  _A_IEN0
       1  _A_IEN1
       1  _A_IRCON2
       4  __Constant_7d
     129  __low_level_init
       8  dmaCh0
       1  forcePin
     242  gpioInit
      16  hexDigit
       4  languageId
      23  main
      36  manufacturer
       2  pFnSuspendEnterHook
       2  pFnSuspendExitHook
       2  pForcePort
    2048  pgBuf
      36  product
      42  serialNumber
       4  stDelay
       4  stStart
       2  status
      83  ublAesAuth
       5  ublAesCrypt
     174  ublCfg
     263  ublExec
     300  ublInit
      13  ublJump
     100  ublMD
      77  ublMassErase
      32  unlockedSecKey
       5  usbSetupData
       8  usbSetupHeader
       2  usbdpData
      71  usbdpFindNext
      54  usbdpGetConfigurationDesc
      16  usbdpGetDeviceDesc
      49  usbdpGetInterfaceDesc
     148  usbdpGetStringDesc
      20  usbdpInit
      20  usbfwData
      56  usbfwInit
      39  usbfwReadFifo
      31  usbfwResetHandler
      50  usbfwSetAllEpStatus
     519  usbfwSetupHandler
      41  usbfwWriteFifo
       5  usbirqData
     161  usbirqHandler
      62  usbirqInit
      18  usbsrClearFeature
      47  usbsrGetConfiguration
     360  usbsrGetDescriptor
      74  usbsrGetInterface
     226  usbsrGetStatus
      70  usbsrSetAddress
     167  usbsrSetConfiguration
      18  usbsrSetFeature
     118  usbsrSetInterface
      61  usbsuspDoRemoteWakeup

 
 4 757 bytes in segment BANKED_CODE
   228 bytes in segment BANK_RELAYS
     7 bytes in segment DATA_Z
   129 bytes in segment NEAR_CODE
    20 bytes in segment SFR_AN
    42 bytes in segment XDATA_I
    42 bytes in segment XDATA_ID
 2 167 bytes in segment XDATA_N
   146 bytes in segment XDATA_ROM_C
    41 bytes in segment XDATA_Z
 
 5 156 bytes of CODE  memory
   142 bytes of CONST memory (+  4 bytes shared)
     7 bytes of DATA  memory (+ 20 bytes shared)
 2 250 bytes of XDATA memory

Errors: none
Warnings: none
